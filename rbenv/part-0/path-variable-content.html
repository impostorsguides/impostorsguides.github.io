<header class="post-header">
  <h1 class="post-title">The <code>$PATH</code> Variable</h1>
</header>

<p>As mentioned earlier, one important example of an environment variable is the <code>PATH</code> variable.</p>

<p>If we look up the manual entry for <code>env</code>, we see the following:</p>

<pre><code>ENV(1)                                                            General Commands Manual                                                           ENV(1)

NAME
      env â€“ set environment and execute command, or print environment
...
DESCRIPTION
      The env utility executes another utility after modifying the environment as specified on the command line.  Each name=value option specifies the
      setting of an environment variable, name, with a value of value.  All such environment variables are set before the utility is executed.

</code></pre>

<p>So when we type <code>/usr/bin/env bash</code>, we're setting environment variables and then running the <code>bash</code> command.  One of the environment variables we're setting is <code>PATH</code>.</p>

<p><code>PATH</code> contains a list of directories that UNIX will search through, when it looks for the command we include in our shebang (whether that command is <code>bash</code>, <code>ruby</code>, or something else).  Because UNIX will search <code>PATH</code> in the order in which directories appear, <code>PATH</code> also determines which versions of a given executable take precedence over others, if multiple versions are included in <code>PATH</code>.</p>

<p>Throughout this chapter, I'm going to use a simpler, shorter version of my computer's regular <code>$PATH</code> variable.  This is both to make it more readable and so I can format this page for both web browsers and PDFs.  The value I'll use will be:</p>

<pre><code>/Users/richiethomas/.rbenv/shims:
/usr/local/sbin:
/usr/local/bin:
/usr/bin:
/bin</code></pre>

<p>I split the above into one path per line for readability reasons (and I'll have to do that often in this chapter), but note that <code>$PATH</code> will normally print out as a single, long string.  Later in this chapter, we will write a script to do this splitting for us.</p>

<p>If my shebang is <code>#!/usr/bin/env ruby</code>, and my <code>PATH</code> variable is the above value, then UNIX will check for the <code>ruby</code> command in the following directories, in the same order listed above.</p>

<p>So if my <code>/usr/local/bin</code> folder contains Ruby version 2.7.5, and my <code>/usr/bin</code> folder contains Ruby version 1.9.3, then a Ruby script which contains the shebang <code>#!/usr/bin/env Ruby</code> will tell UNIX to run that script using Ruby version 2.7.5.</p>

<p>Let's do an experiment to verify this is true.</p>

<h2>Experiment- setting our own <code>$PATH</code></h2>

<p>In my <code>scratch/</code> directory, I create two sub-directories: <code>foo/</code> and <code>bar/</code>.  Next, I create a file in each directory.  These two files print different strings, but they share the same name: <code>baz</code>.</p>

<p>The <code>foo/baz</code> file looks like this:</p>

<pre><code>#!/usr/bin/env bash

echo 'Inside foo'</code></pre>

<p>And <code>bar/baz</code> looks like this:</p>

<pre><code>#!/usr/bin/env bash

echo 'Inside bar'</code></pre>

<p>I run <code>chmod +x</code> on each file, to make sure they're executable.</p>

<p>When I run <code>ls -Rla</code>, I see the following:</p>

<pre><code>$ ls -lRa
total 0
drwxr-xr-x  4 richiethomas  staff  128 Jan 11 11:35 .
drwxr-xr-x  6 richiethomas  staff  192 Jan 11 10:35 ..
drwxr-xr-x  3 richiethomas  staff   96 Jan 11 11:36 bar
drwxr-xr-x  3 richiethomas  staff   96 Jan 11 11:36 foo

./bar:
total 8
drwxr-xr-x  3 richiethomas  staff   96 Jan 11 11:36 .
drwxr-xr-x  4 richiethomas  staff  128 Jan 11 11:35 ..
-rw-r--r--  1 richiethomas  staff   39 Jan 11 11:36 baz

./foo:
total 8
drwxr-xr-x  3 richiethomas  staff   96 Jan 11 11:36 .
drwxr-xr-x  4 richiethomas  staff  128 Jan 11 11:35 ..
-rw-r--r--  1 richiethomas  staff   39 Jan 11 11:36 baz
$ </code></pre>

<p>The <code>-R</code> flag after <code>ls</code> just tells the shell to recursively list the contents of the current directory and any sub-directories.</p>

<p>Next, I update my <code>$PATH</code> variable so that it begins with the <code>bar/</code> and <code>foo/</code> directories, for my current terminal tab only.  In my case, I run:</p>

<pre><code>$ PATH="/Users/richiethomas/Desktop/Workspace/scratch/bar/:\
/Users/richiethomas/Desktop/Workspace/scratch/foo/:$PATH"</code></pre>

<p>Notice that the above string contains two absolute paths (one for <code>/Users/richiethomas/Desktop/Workspace/scratch/bar/</code> and one for <code>/Users/richiethomas/Desktop/Workspace/scratch/foo/</code>), followed by the original value of <code>$PATH</code>.  This means we're prepending <code>$PATH</code> with our two new absolute paths, with <code>bar</code> coming before <code>foo</code>.</p>

<p>The command you run will be different, because your home directory will include a different username.</p>

<p>Below are the "before" and "after" versions my <code>$PATH"</code> environment variable:</p>

<pre><code>$ echo $PATH                                                                           
/Users/richiethomas/.rbenv/shims:
/usr/local/sbin:
/usr/local/bin:/
usr/bin:
/bin/

$ PATH="/Users/richiethomas/Desktop/Workspace/scratch/bar/:\
/Users/richiethomas/Desktop/Workspace/scratch/foo/:\
$PATH" 

$ echo $PATH                                                                                                        
/Users/richiethomas/Desktop/Workspace/scratch/bar/:
/Users/richiethomas/Desktop/Workspace/scratch/foo/:
/Users/richiethomas/.rbenv/shims:
/usr/local/sbin:
/usr/local/bin:
/usr/bin:
/bin/

$</code></pre>

<p>Notice that altering <code>$PATH</code> resulted in the <code>bar</code> and <code>foo</code> paths being added to the front of <code>$PATH</code>, in that order.</p>

<p>By the way, it's important <strong>not</strong> to use <code>~/</code> when adding the 2 new directories to the front of your <code>$PATH</code>.  You have to use the <i>absolute path</i> instead.  For example, in my case, I had to use <code>/Users/richiethomas/Workspace/OpenSource/scratch/bar/</code>, not <code>~/Workspace/OpenSource/scratch/bar/</code>, even though they mean the same thing in most cases.</p>

<p>Lastly, I run <code>baz</code> in my current terminal:</p>

<pre><code>$ baz
Inside bar
$ </code></pre>

<p>We see "Inside bar", not "Inside foo".  That's because, even though we have two different <code>baz</code> files, and they're each executable, the file inside the <code>bar/</code> directory comes first in our <code>$PATH</code> environment variable.</p>

<h2><code>$IFS</code> and delimiters</h2>

<p>The directories in the <code>PATH</code> string are concatenated together into a single string, with the <code>:</code> character used as a delimiter. This delimiter is also called an <a href="https://web.archive.org/web/20220715010436/https://www.baeldung.com/linux/ifs-shell-variable" target="_blank">"internal field separator"</a>, and UNIX refers to it by the environment variable <code>$IFS</code>.</p>

<p>The link above contains an experiment, which I've modified slightly below so we can see an example of how it's used.</p>

<h3>Experiment- printing "$PATH" in a readable way, using "$IFS"</h3>

<p>Our <code>$PATH</code> variable is pretty inscrutable, with all those directories concatenated together. Let's write a script to make it easier to read.</p>

<p>I delete the <code>foo/</code> and <code>bar/</code> directories to get a clean slate, and create a new file named <code>foo</code>:</p>

<pre><code>#!/usr/bin/env bash

string="$PATH"

for path in $string
do
  echo "$path"
done
</code></pre>

<p>As with any new script file, I have to <code>chmod +x</code> it if I want to run it.</p>

<p>When I run the script, I see:</p>

<pre><code>$ echo $PATH
/Users/richiethomas/Desktop/Workspace/scratch/bar/:/Users/richiethomas/Desktop/Workspace/scratch/foo/:/Users/richiethomas/.rbenv/shims:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin/
</code></pre>

<p>No improvement in readability so far.</p>

<p>Then, I add the following to the top of the script:</p>

<pre><code>#!/usr/bin/env bash

IFS=":"    # <= I added this

string="$PATH"

for path in $string
do
  echo "$path"
done
</code></pre>

<p>When I re-run the script, I get:</p>

<pre><code>$ ./foo
  /Users/richiethomas/Desktop/Workspace/scratch/bar/
  /Users/richiethomas/Desktop/Workspace/scratch/foo/
  /Users/richiethomas/.rbenv/shims
  /usr/local/sbin
  /usr/local/bin
  /usr/bin
  /bin/

$ </code></pre>

<p>This experiment also shows that iterating over a string is similar to iterating over an array, once we tell the terminal how to split the string from one large item into several smaller items via <code>$IFS</code>.</p>

<p>So if, like my machine, yours uses the "space" character, then a string like "foo bar baz" (with 3 words and two spaces) will be separated into 3 separate strings ("foo", "bar", and "baz") if you iterate over the string and print each item.</p>

<p>Let's move on to line 2 of the shim file.</p>