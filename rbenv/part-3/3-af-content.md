Now we move onto the `rbenv/src/` directory.

First file: [`Makefile.in`](https://github.com/rbenv/rbenv/blob/c4395e58201966d9f90c12bd6b7342e389e7a4cb/src/Makefile.in){:target="_blank" rel="noopener"}.

This file is short, just 25 lines of code:

```
CC = @CC@

CFLAGS = @CFLAGS@
LOCAL_CFLAGS = @LOCAL_CFLAGS@
DEFS = @DEFS@
LOCAL_DEFS = @LOCAL_DEFS@

CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(LOCAL_CFLAGS) $(CFLAGS)

SHOBJ_CC = @SHOBJ_CC@
SHOBJ_CFLAGS = @SHOBJ_CFLAGS@
SHOBJ_LD = @SHOBJ_LD@
SHOBJ_LDFLAGS = @SHOBJ_LDFLAGS@
SHOBJ_XLDFLAGS = @SHOBJ_XLDFLAGS@
SHOBJ_LIBS = @SHOBJ_LIBS@
SHOBJ_STATUS = @SHOBJ_STATUS@

.c.o:
	$(SHOBJ_CC) $(SHOBJ_CFLAGS) $(CCFLAGS) -c -o $@ $<

../libexec/rbenv-realpath.dylib: realpath.o
	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ realpath.o $(SHOBJ_LIBS)

clean:
	rm -f *.o ../libexec/*.dylib
```

And we already saw when we read about the `configure` script that the first 16 lines of this file will be replaced by variable values generated by the `shobj-conf` file.  So let's focus on the remaining 6 lines:

```
.c.o:
	$(SHOBJ_CC) $(SHOBJ_CFLAGS) $(CCFLAGS) -c -o $@ $<

../libexec/rbenv-realpath.dylib: realpath.o
	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ realpath.o $(SHOBJ_LIBS)

clean:
	rm -f *.o ../libexec/*.dylib
```

These lines aren't affected by the `sed` command in the `configure` script- no part of them gets replaced.  So these lines appear exactly the same in both `Makefile.in` and `Makefile`.

But before we get into what this syntax is, let's look at what Makefiles are.

## What is a Makefile?

The most comprehensive resource I found on Makefiles is a website called [MakefileTutorial.com](https://web.archive.org/web/20230723010515/https://makefiletutorial.com/){:target="_blank" rel="noopener"}.  It tells us that:

> Makefiles are used to help decide which parts of a large program need to be recompiled. In the vast majority of cases, C or C++ files are compiled. Other languages typically have their own tools that serve a similar purpose as Make. Make can also be used beyond compilation too, when you need a series of instructions to run depending on what files have changed.

It goes on to talk about dependency graphs, and how a Makefile can be used to construct a dependency graph which tells your computer to recompile the dependencies (and the things which depend on them) if any of them change.

Additionally, according to [OpenSource.com](https://web.archive.org/web/20230701183057/https://opensource.com/article/18/8/what-how-makefile){:target="_blank" rel="noopener"}:

> If you want to run or update a task when certain files are updated, the `make` utility can come in handy. The `make` utility requires a file, `Makefile` (or `makefile`), which defines set of tasks to be executed.

So the program which reads your `Makefile` and re-compiles your dependencies is called `make`.

Let's create a simple Makefile as an experiment, following along with the first example from the above [MakefileTutorial.com link](https://web.archive.org/web/20230723010515/https://makefiletutorial.com/){:target="_blank" rel="noopener"}.

### Experiment- building a trivial Makefile example

I create a new file named `Makefile` and, inside it, copy/paste the following directly from the above link:

```
hello:
	echo "Hello, World"
	echo "This line will always print, because the file hello does not exist."
```

Then I run `make hello` in the same directory as the `Makefile`.  I see the following:

```
$ make

echo "Hello, World"
Hello, World
echo "This line will always print, because the file hello does not exist."
This line will always print, because the file hello does not exist.
```

So far, so good.

The tutorial tells us what the different parts of our `Makefile` are:

 - `hello:`- the *target* of the file.
 - The two `echo` statements- the *commands* of the file.
 - No *prerequisites* are listed here (but we'll see some later).

The tutorial also says the following:

> As long as the `hello` file does not exist, the commands will run. If hello does exist, no commands will run.
>
> It's important to realize that I'm talking about hello as both a target and a file. That's because the two are directly tied together. Typically, when a target is run (aka when the commands of a target are run), the commands will create a file with the same name as the target. In this case, the hello target does not create the hello file.

So by convention, if we have a target named `foobar`, the expectation is that the target's commands will result in the creation of a file with the same name, i.e. `foobar`.  But importantly, if that file already exists, the commands won't be run.

To test this, I create an empty file named `hello`, and re-run `make hello`:

```
$ touch hello

$ make hello

make: `hello' is up to date.
```

This time, we don't see the two `echo` statements, or their output, in the terminal.

## The RBENV Makefile

Let's now look at the code inside the RBENV version of `Makefile`.  We learned earlier that this file is generated when reading the `configure` script.  `Makefile` looks like this:

```
CC = gcc

CFLAGS =
LOCAL_CFLAGS =
DEFS =
LOCAL_DEFS =

CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(LOCAL_CFLAGS) $(CFLAGS)

SHOBJ_CC = gcc
SHOBJ_CFLAGS = -fno-common
SHOBJ_LD = ${CC}
SHOBJ_LDFLAGS = -dynamiclib -dynamic -undefined dynamic_lookup
SHOBJ_XLDFLAGS =
SHOBJ_LIBS =
SHOBJ_STATUS = supported

.c.o:
	@echo "1st command: $(SHOBJ_CC) $(SHOBJ_CFLAGS) $(CCFLAGS) -c -o $@ $<"
	$(SHOBJ_CC) $(SHOBJ_CFLAGS) $(CCFLAGS) -c -o $@ $<

../libexec/rbenv-realpath.dylib: realpath.o
	@echo "2nd command: $(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ realpath.o $(SHOBJ_LIBS)"
	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ realpath.o $(SHOBJ_LIBS)

clean:
	rm -f *.o ../libexec/*.dylib
```

Let's start with the first rule, since everything before it is just variable declarations.

## The `.c.o` rule

```
.c.o:
	@echo "1st command: $(SHOBJ_CC) $(SHOBJ_CFLAGS) $(CCFLAGS) -c -o $@ $<"
	$(SHOBJ_CC) $(SHOBJ_CFLAGS) $(CCFLAGS) -c -o $@ $<
```

