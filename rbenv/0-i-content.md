### Investigating the origins of the `if` block in the shim file

If you give `ruby` a filename to run in the form of `path/to/filename.rb`, RBENV will look for the `.ruby-version` file in the file's directory *even if that directory is not the one you're in now*.  And that directory may have its own `.ruby-version` file, possibly containing a different Ruby version from the one you're currently using.

My theory is that the purpose of this logic is to handle the case where you're running a Ruby file from a different directory, one with a (potentially) different Ruby version.  To see whether this is true, let's use git and Github to find the commit which introduced this change.  From there, we can see whether there was any discussion around why it was introduced.

#### Experiment- using git + Github to find where a change was introduced

In order to find the PR that introduced the if-block, I need the SHA for the commit from that PR.  But the shim files are auto-generated by RBENV whenever you install a new gem, meaning they're not part of a git repo (and hence don't have their own SHA).

However, since the shims are all the same, I bet there's a great chance that the shim code lives in a single file somewhere in the RBENV codebase, and is just copy-pasted into a new file whenever a new gem is installed.

I need to search the RBENV codebase for that code, so I pick a line from the if-block.  The line that I pick is one which I think will not be too common in the codebase, and therefore, it will have a high signal-to-noise ratio in my search results.  Then I use [the `ag` tool](https://github.com/ggreer/the_silver_searcher) to find its location:

<p style="text-align: center">
  <img src="/assets/images/ag-program-equals.png" width="70%" alt="searching or the shim code">
</p>

The only result I get is from a file named `libexec/rbenv-rehash`, on line 64.  Let's have a closer look at that line of code:

<p style="text-align: center">
  <img src="/assets/images/create-prototype-shim.png" width="50%" alt="the 'create-prototype-shim' method in rbenv-rehash">
</p>

Looks like it lives inside a function called `create_prototype_shim`.  Seems like we're on the right track!

Now that we know where in the RBENV codebase the if-block comes from, let's look at the git history for that file.  I copy the filepath for `rbenv-rehash` and run `git blame` on it (docs on this command [here](https://archive.ph/iSiLS)):

<p style="text-align: center">
  <img src="/assets/images/git-blame-rbenv-rehash.png" width="70%" alt="output of the `git blame` command for the `libexec/rbenv-rehash` file">
</p>

This is a lot of info, but what we care about is the left-most column.  It contains the first 8 characters of the commit's unique identifier (also called a SHA) which introduced each line of code.  In our case, we want line 64 (the line numbers are located in the 2nd-to-right column, just to the left of the actual lines of code).

Lucky for us, the SHA (`283e67b5`) is the same for the entire if-block, so we can be fairly confident that this is indeed the SHA which introduced the entire if-block.  If there were many different SHAs, each with different commit dates, that would indicate this code had been edited and re-edited many times, and any one of those SHAs could have been the original one.  In that case, it would be more of a slog to see which commit contained the info we're looking for.

I open my web browser and go to Github, where I paste the SHA value I copied from `git blame` into the search bar on the top-left and select "In this repository":

<p style="text-align: center">
  <img src="/assets/images/searching-github-for-sha.png" width="70%" alt="output of the `git blame` command for the `libexec/rbenv-rehash` file" style="border: 1px solid black; padding: 0.5em">
</p>

Although Github says "we couldn't find any code...", we're not looking for answers from the *codebase*, but rather from the *git history*.  And on the left-hand side, we can see that Github did find one issue and one commit containing this SHA.  I right click on each section to open them in new tabs.

First the commit results:

<p style="text-align: center">
  <img src="/assets/images/git-commit-history-for-sha.png" width="70%" alt="Github's results for the commit history containing our SHA" style="border: 1px solid black; padding: 0.5em">
</p>

Reconstructing the commit message (which was cut off due to length), we can see at the top that the commit message for this commit was:

```
When the ruby shim is invoked with a script, set RBENV_DIR to the script's dirname
```

This definitely sounds like we're on the right track.  Let's also check [the issue link](https://github.com/rbenv/rbenv/pull/299):

<p style="text-align: center">
  <img src="/assets/images/rbenv-issue-page.png" width="50%" alt="The newer Github issue related to the PR which introduced this if-block." style="border: 1px solid black; padding: 0.5em">
</p>


The description says `This branch adjusts the behavior of the ruby shim, when invoked with the path to a Ruby script as an argument, to set RBENV_DIR to the directory of the given script.  It should, in effect, remove the need for the ruby-local-exec shebang line.`  That sounds pretty close to what we hypothesized.

Based on this, I think we can safely say that the if-block was added in order to take the Ruby script's filesystem location into account when setting the `RBENV_DIR` environment variable, *regardless of whether it's located in the current directory tree or a different one*.

### The `ruby-local-exec` shebang

But there's something here I still don't understand, specifically that 2nd sentence `It should, in effect, remove the need for the ruby-local-exec shebang line.`  It sounds like there was a previous attempt to solve the problem of setting `RBENV_DIR` which involved a special type of shebang, called `ruby-local-exec`.  That makes me wonder:

 - How did `ruby-local-exec` originally work?
 - Why did the core team feel the need to replace it?  What was wrong with it?
 - Why was our adding of the `if`-block an improvement on that old strategy?

#### Looking for `ruby-local-exec`

I suspect that `ruby-local-exec` is a file.  After all, the interpreters that shebangs use (such as the `bash` in `#!/usr/bin/env bash` or the `ruby` in `#!/usr/bin/env ruby`) are just executable files, so `ruby-local-exec` might be a file too.  If it is a file, there must have been a git commit somewhere which introduced the file.  Maybe we can use the same strategy here that we used with the if-block.

Since our original Github issue said that the need for the `ruby-local-exec` shebang had been removed, I suspect this file no longer exists in the codebase.  I run `find . -name ruby-local-exec` and no results appear, so that seems to check out.  This means I have to search Github for an older version of the repository which contains the file.

I type "ruby-local-exec" in Github's search field while inside the Github repository (i.e. while my browser is pointed to `https://github.com/rbenv/rbenv`).  When I do this, the "In this repository" option appears in a dropdown, and I click that.

<p style="text-align: center">
  <img src="/assets/images/ruby-local-exec-search.png" width="70%" alt="Searching Github for the string 'ruby-local-exec'." style="border: 1px solid black; padding: 0.5em">
</p>

I'm taken to a search results page, which (among other things) indicates that Github found 6 commits with this string present.  I click on "Commits" to see which commits those were:

<p style="text-align: center">
  <img src="/assets/images/search-results-for-ruby-local-exec.png" width="70%" alt="Github Search results for the string 'ruby-local-exec'." style="border: 1px solid black; padding: 0.5em">
</p>

From there, I see a list of git commits, along with their commit messages.  The commit labeled "Add experimental `ruby-local-exec`" [looks promising](https://github.com/rbenv/rbenv/commit/1411fa5a1624ca5eeb5582897373c58a715fe2d2), so I click on that:

<p style="text-align: center">
  <img src="/assets/images/search-results-for-ruby-local-exec-2.png" width="70%" alt="Github Search results for the string 'ruby-local-exec'." style="border: 1px solid black; padding: 0.5em">
</p>

From there, I'm taken to a list of files, which (in the case of this PR) is just one file- the one I want (`bin/ruby-local-exec`):

<p style="text-align: center">
  <img src="/assets/images/ruby-local-exec-commit.png" width="70%" alt="The original commit for the 'ruby-local-exec' file." style="border: 1px solid black; padding: 0.5em">
</p>

Great, so we finally have confirmation that `ruby-local-exec` was indeed a file at some point.

#### What does `ruby-local-exec` actually do?

Now that we have the file, we can read its code to answer question #1 above ("How did `ruby-local-exec` originally work?").

The code for `ruby-local-exec` was as follows:

```
set -e

cwd="$(pwd)"
dirname="${1%/*}"

cd "$dirname"
export RBENV_VERSION="$(rbenv version-name)"
cd "$cwd"

exec ruby "$@"
```

The first line was:

```
set -e
```

We've seen this command before, so we know what that does- it tells `bash` to exit immediately when it encounters an error.

```
cwd="$(pwd)"
```

We're storing something in a variable called "cwd", but what?

The `pwd` string looks like the `pwd` bash command I'm previously familiar with.  It stands for "print working directory", and it prints the full path for the directory you're currently in:

```
$ pwd

/Users/myusername/Workspace/OpenSource
```

And it *almost* looks like we're doing parameter expansion again, except this time the syntax uses parentheses instead of curly braces.  Is that what this is?

I Google "bash difference between brackets and parentheses", and the first link I get is [this StackOverflow post](https://archive.ph/3IjOm) with this answer:

<p style="text-align: center">
  <img src="/assets/images/parens-in-bash.png" width="70%" alt="What is the difference between curly braces and parentheses in bash?" style="border: 1px solid black; padding: 0.5em">
</p>

OK, so "Parentheses cause the commands to be run in a subshell."  What's a subshell?

I Google "what is a subshell bash" and get [this link](https://archive.ph/7mszR):

<p style="text-align: center">
  <img src="/assets/images/what-are-subshells.png" width="70%" alt="What are subshells in bash?" style="border: 1px solid black; padding: 0.5em">
</p>

So the code `cwd="$(pwd)"` creates a subshell, runs the `pwd` command inside that subshell, and stores the output of the command inside a new variable named `cwd`.  I subsequently learned that this is also known as ["command substitution"](https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html).

```
dirname="${1%/*}"
```

This is definitely parameter expansion again.  What effect does the `%/*` have?  Referring back to [an earlier section of this post](#experiment--more-fun-with-parameter-expansion), we're reminded that `%/*` trims off the last `/` character and everything after it.  Which makes sense if we're trying to capture a directory name in a variable named `dirname`.

To see which dirname we're storing, I run an experiment.

#### Experiment- creating our own shebang

I copy-paste the original `ruby-local-exec` into a new file in my current directory (remembering to run `chmod +x` on that new file).  I add a few `echo` loglines, like so:

<p style="text-align: center">
  <img src="/assets/images/new-shebang.png" width="50%" alt="contents of my copy of the ruby-local-exec shebang" >
</p>

I then create a new file called `foo`, which looks like so:

<p style="text-align: center">
  <img src="/assets/images/using-the-new-shebang.png" width="50%" alt="using the new shebang" >
</p>

The `ruby-local-exec` shebang is meant to execute Ruby scripts, so my `foo` script uses Ruby syntax like the `puts` statement.

The last thing I have to do is update my `PATH` variable to begin with my current directory, so that UNIX will know where to find the `ruby-local-exec` file (and therefore, it will know how to run my `foo` script).  I can feel free to do this directly in my terminal without worrying that it'll cause any damage- changes to my `PATH` that I make directly at the command line won't be propagated to any other terminal tabs I open.

I run the following in my terminal:

```
$ PATH="$(pwd):$PATH"
$ which ruby-local-exec

/Users/myusername/Workspace/OpenSource/rbenv/ruby-local-exec
```

Running `which ruby-local-exec` shows me that UNIX can now find my `ruby-local-exec` command in `PATH`.  Now, when I run `./foo` in my terminal, I see:

```
$ ./foo

start of ruby-local-exec
dirname: .
just before exec in ruby-local-exec
Hello world
```

We see that `dirname` evaluates to `.`.  I suspect this is because I ran the command as `./foo` and the parameter expansion chopped off the trailing `/foo`.  When I re-run the command with the full directory, I see:

```
$ pwd
/Users/myusername/Workspace/OpenSource/rbenv

$ /Users/myusername/Workspace/OpenSource/rbenv/foo

start of ruby-local-exec
dirname: /Users/myusername/Workspace/OpenSource/rbenv
just before exec in ruby-local-exec
Hello world
```

This time, `dirname` evaluates to `/Users/myusername/Workspace/OpenSource/rbenv`.  This must mean that, inside the shebang file, the parameter expansion `${1}` evaluates to the filename.  We can quickly test this by adding a logline to output just that, without any modifications to `$1`.  Above the logline for `dirname` inside my new shebang, I add:

```
echo "1: ${1}"
```

When I re-run, I get:

```
$ /Users/myusername/Workspace/OpenSource/rbenv/foo

start of ruby-local-exec
1: /Users/myusername/Workspace/OpenSource/rbenv/foo
dirname: /Users/myusername/Workspace/OpenSource/rbenv
just before exec in ruby-local-exec
Hello world
```

Yep, `${1}` inside the shebang evaluated to the filename.

Next line of code:

```
cd "$dirname"
```

Here we're just using `cd` to navigate into the dirname we just stored.  We don't yet know why (that will come later), but this line is straight-forward.

Next line:

```
export RBENV_VERSION="$(rbenv version-name)"
```

Here we're again using command substitution, this time to store the output of `rbenv version-name` in an environment variable named `RBENV_VERSION`.  What's the output of `rbenv version-name`?  Running it in my terminal, I see:

```
$ rbenv version-name

2.7.5
```

OK, so we're just storing the current Ruby version inside `RBENV_VERSION`.  But is it the version of the folder we're in, or the version of the folder containing our Ruby script?

Before moving on, I remove all the loglines I've added to `ruby-local-exec` so far.

#### Experiment- which directory's Ruby version does `RBENV_VERSION` contain?

I add a logline inside my new shebang file, just after the assignment to `RBENV_VERSION`, which will `echo` the contents of that env var:

```
echo "RBENV_VERSION: $RBENV_VERSION"
```

I then create a `.ruby-version` file in the same directory as my `foo` script, containing only the string "2.7.5":

```
$ echo "2.7.5" > .ruby-version
```

I then navigate up one directory create a new directory called `bar`, navigate into that, and create a 2nd `.ruby-version` file in this directory, which I set to "3.0.0":

```
~/Workspace/OpenSource/rbenv (master)  $ cd ..
~/Workspace/OpenSource ()  $ mkdir bar
~/Workspace/OpenSource ()  $ cd bar
~/Workspace/OpenSource/bar ()  $ echo "3.0.0" > .ruby-version
~/Workspace/OpenSource/bar ()  $
```

Lastly, I copy my `foo` script from the `rbenv` directory into my new `bar` directory:

```
$ cp ../rbenv/foo .
```

Then, from the `bar` directory, I execute the `foo` script *in the `rbenv` directory*:

```
$ ../rbenv/foo

RBENV_VERSION: 2.7.5
Hello world
```

Lastly, when I run the copy of `foo` *in the `bar` directory*, I see:

```
$ ./foo

RBENV_VERSION: 3.0.0
Hello world
```

So when I run the copy of `foo` in the `rbenv` directory, I see that `RBENV_VERSION` is `2.7.5`.  But when I run `foo` from the `bar` directory, I see `3.0.0`.  We can therefore conclude that RBENV will first look for a `.ruby-version` file in the directory of the script that is being executed, before checking in any other locations (such as the directory the user is currently in when they execute that script).

--------

Next line of code:

```
cd "$cwd"
```

So now we're just changing back to the directory we were originally in when we stored `pwd` inside the `cwd` variable.  Essentially we just ran `cwd="$(pwd)"` so that we would know where to navigate back to after we had stored the right Ruby version inside `RBENV_VERSION`.

Last line of code:

```
exec ruby "$@"
```

Here we're using the `exec` command that we learned about [earlier](#executing-the-original-gem), using it to call `ruby`, and passing along any arguments that the script may have received.  Remember that this will be the *shim* of Ruby, not the original Ruby interpreter itself.

OK, so that's the answer to our first question, about what `ruby-local-exec` does!  Now for question #2: why did the core team feel the need to replace it?

#### Why did the core team replace `ruby-local-exec`?

For this, we'll have to search for discussions amongst the core team (in the form of comments and issues on Github pages) which relate to this file.  I don't remember [our original Github issue page](https://github.com/rbenv/rbenv/pull/299) containing any of those discussions, but I do remember that there was a link to a previous discussion:

<p style="text-align: center">
  <img src="/assets/images/see-previous-discussion.png" width="70%" alt="Link to an earlier discussion about ruby-local-exec." style="border: 1px solid black; padding: 0.5em">
</p>

Clicking this link, I'm taken to [the page for an earlier PR](https://github.com/rbenv/rbenv/pull/298), one that was apparently closed.  The IDs of the 2 PRs are sequential (the IDs are 298 for the cloed one and 299 for the merged one), and their intent is identical, so it's a safe bet that the earlier one was closed in favor of the later one.

#### Why the switch from `.rbenv-version` to `.ruby-version`?

This PR's discussion references a file named `.rbenv-version`, which is of course different from the `.ruby-version` file we've previously discussed.  My guess is that, at some point, the RBENV core team switched from a naming convention of `.rbenv-version` to `.ruby-version`, in order to be slightly more inter-operable with other Ruby version managers.  A quick Github search in the RBENV repo for `".rbenv-version" ".ruby-version"` (so that I can find PRs which contain both terms) yields 8 results, of which [this PR](https://github.com/rbenv/rbenv/pull/302) is one.  This quote in particular stands out among the comments:

<p style="text-align: center">
  <img src="/assets/images/switch-rbenv-version-to-ruby-version.png" width="70%" alt="Comments discussing the support of the '.ruby-version' filename over '.rbenv-version'." style="border: 1px solid black; padding: 0.5em">
</p>

This largely confirms my suspicions about inter-operability.

FWIW, there's also a comment by Sam Stephenson (the original author and member of the core team) saying:

```
We will maintain backwards compatibility with existing .rbenv-version files for the foreseeable future.
```

However, when I search my local version of the codebase for `.rbenv-version`, nothing is returned, whereas `.ruby-version` has plenty of references.  So I'm guessing that the plan to support the `.rbenv-version` filename convention must have scrapped at some point.

#### Looking for the commit which added `ruby-local-exec`

On the right-hand side of the screen, I see the following:

<p style="text-align: center">
  <img src="/assets/images/commit-SHA-for-ruby-local-exec.png" width="50%" alt="Original commit SHA for the 'ruby-local-exec' file." style="border: 1px solid black; padding: 0.5em">
</p>

Among other things, this tells us that the SHA for this commit starts with `1411fa5`.  In my terminal, I navigate to my local copy of the RBENV codebase and run `git checkout 1411fa5`:

<p style="text-align: center">
  <img src="/assets/images/navigating-to-correct-SHA.png" width="50%" alt="Running `git checkout` to check out the correct SHA." >
</p>

I run `ls bin/ruby-local-exec` to verify that the file exists in this version of the repo, then run `git co HEAD~` to check out the commit *just before* the current one and re-run `ls bin/ruby-local-exec` to verify that the file *no longer exists*:

<p style="text-align: center">
  <img src="/assets/images/verifying-no-file-exists.png" width="50%" alt="verifying I have the correct SHA." >
</p>

This proves that `1411fa5` is indeed the SHA which introduced the shebang file.

#### Checking Github for context around this SHA

Now that I know I have the SHA which introduced this file, I can plug *that* back into Github search to look for any issues or discussions around this change:

<p style="text-align: center">
  <img src="/assets/images/gh-search-using-sha.png" width="50%" alt="Github search using SHA as search term." style="border: 1px solid black; padding: 0.5em">
</p>

<p style="text-align: center">
  <img src="/assets/images/gh-search-using-sha-results.png" width="50%" alt="Results of Github search using SHA as search term." style="border: 1px solid black; padding: 0.5em">
</p>

All we see is the 1 commit which introduced this change.  There are no issues associated with this commit.  Unfortunately, that means there is no discussion around why it was introduced or what problems it solves.

### A last resort

As a last resort, I try ChatGPT haha:

<!-- ChatGPT link- https://chat.openai.com/chat/1a2694aa-d446-46b0-a1dd-f40d24377efb -->

<p style="text-align: center">
  <img src="/assets/images/chat-gpt-why-change-shebang.png" width="70%" alt="Asking ChatGPT why RBENV changed their shebang from `ruby-local-exec` to `ruby`."  style="border: 1px solid black; padding: 0.5em">
</p>

ChatGPT says that the newer `ruby` shebang is simpler, more reliable, and more portable than the old `ruby-local-exec` shebang.  Though I don't have any non-AI-generated evidence to support this, it seems like a plausible explanation.

### A warning- getting burned by ChatGPT

I don't want to imply that ChatGPT is a good resource to use in all cases.  It definitely pays to verify any claims it makes.

For example, when I was trying to figure out why files aren't executable-by-default by their creator, I hit a dead end where I couldn't find an authoritative answer online.  So once again, I turned to ChatGPT.  This time the answer it gave me was misleading.  The question I asked was:

```
In a UNIX environment, why aren't new files executable by the creator of the file until you run the `chmod`
command?  Shouldn't the file's creator automatically have the ability to execute the file?
```

And the answer it gave was:

<p style="text-align: center">
  <img src="/assets/images/chat-gpt-why-arent-files-executable-by-default.png" width="70%" alt="Asking ChatGPT why files aren't executable by their creator until `chmod` is run.">
</p>

The answer is partially correct (the goal of the policy is in fact to prevent a malicious user from executing code which could harm your system).  But I wanted to verify the statement `When a new file is created, it inherits the default permissions of the directory it was created in...`.

So I did an experiment.  I made a directory and verified that its permissions were such that the user who created it could "execute" it:

```
$ mkdir foo

$ chmod +x foo

$ ls -l

...
drwxr-xr-x   3 myusername  staff   96 Mar  6 08:43 foo
...
```

Then I created a file inside that directory.  But that file was not, by default, executable by its creator:

```
$ touch foo/bar

$ ls -l foo

total 0
-rw-r--r--  1 myusername  staff  0 Mar  6 08:43 bar
```

This implies that the `foo/bar` file did not inherit its permissions from its parent directory, and that the ChatGPT statement was incorrect.

For added confirmation, I Googled `do unix files inherit the permissions of a directory`, and got [this link](https://archive.ph/uQX9j#selection-1631.0-1645.117) as the first result:

<p style="text-align: center">
  <img src="/assets/images/file-permissions-inheritance-in-unix-1.png" width="70%" alt="Confirming that ChatGPT was not, in fact, correct about UNIX file permissions inheritance.">
</p>

This is confirmed by [this StackOverflow post](https://archive.ph/SFV8x):

<p style="text-align: center">
  <img src="/assets/images/file-permissions-inheritance-in-unix-2.png" width="50%" alt="More confirmation that ChatGPT was not, in fact, correct about UNIX file permissions inheritance.">
</p>

So lesson learned- we can't trust ChatGPT implicitly.

### How was the if-block an improvement on the old solution?

Prior to this change, did RBENV use the Ruby version in the directory from which it was run, *regardless* of what the Ruby version was in the target directory?  To find out, roll back my RBENV and do an experiment.

I `cd` into my RBENV **installation directory** (i.e. `~/.rbenv`), and verify that it is a git repository by running `ls -la` and searching for the `.git` hidden directory.  Then I get the commit SHA from [this link](https://github.com/rbenv/rbenv/pull/299), which I see is SHA `e0b8938fef05dd6d08322e113015c51e79c70291`.  I then run `git checkout e0b8938fef05dd6d08322e113015c51e79c70291` to roll back my installed version to the commit which introduced this change.

Next, in my scratch directory (`~/Workspace/OpenSource`), **I open a new terminal tab**.  This way I'm still in my same directory, but opening the new tab caused my `~/.zshrc` (where I invoke `rbenv init`) to be re-run.  This ensures I'm now using the version of RBENV that I just checked out (i.e. the version corresponding to SHA `e0b8938fef05dd6d08322e113015c51e79c70291`).

I then create two directories in my scratch directory- one named `foo/` and one named `bar/`.  I create a `.rbenv-version` file inside each directory- one set to `3.0.0` in `foo/` and the other set to `2.7.5` in `bar/`.  I then create a file named `script`, which I `chmod +x` so it's executable.  The file looks like this:

```
#!/usr/bin/env ruby

ruby_version = `rbenv version`
puts "Ruby version: #{ruby_version}"
```

The `\`` backtick symbols surrounding `rbenv version` mean that we will run the `rbenv version` terminal command, and store the results in the variable named `ruby_version`.  This process is sometimes called [shelling out](https://stackoverflow.com/a/28655406/2143275) to a sub-process.

I then copy the above `script` file from `foo/` into `bar/`, so an identical file exists in each new directory.  When I run `./script` from within `foo/`, followed by `../bar/script` (also from within `foo/`), I see:

```
~/Workspace/OpenSource/foo ()  $ ./script

Ruby version: 3.0.0 (set by /Users/myusername/Workspace/OpenSource/foo/.rbenv-version)

~/Workspace/OpenSource/foo ()  $ ../bar/script

Ruby version: 2.7.5 (set by /Users/myusername/Workspace/OpenSource/bar/.rbenv-version)
```

Next, back in the `~/.rbenv/` directory, I check out the commit **before** the one which introduced this change:

```
$ git co e0b8938fef05dd6d08322e113015c51e79c70291~

Previous HEAD position was e0b8938 Merge pull request #299 from sstephenson/automatic-local-exec
HEAD is now at 811ca05 Run `hash -r` after `rbenv rehash` when shell integration is enabled
```

Then, back in my `foo/` directory, **I open a new terminal tab again**.  Lastly, when I re-run my two scripts, this time I see:

```
$ ./script

Ruby version: 2.7.5 (set by RBENV_VERSION environment variable)

~/Workspace/OpenSource/foo ()  $ ../bar/script

Ruby version: 2.7.5 (set by RBENV_VERSION environment variable)

~/Workspace/OpenSource/foo ()  $
```

This time, the version numbers are the same- `2.7.5`!  Also, the source of the versions has changed- previously, along with the version number, we saw `(set by /Users/myusername/Workspace/OpenSource/bar/.rbenv-version)` in the output.  This time, we see `(set by RBENV_VERSION environment variable)`.  So in both cases, the `.rbenv-version` file was **not** being used to set the version.

#### Please don't do what I did here

While searching Github for answers to the above, I actually came across [a post of mine](https://github.com/rbenv/rbenv/issues/1173) on this same repository from 2019, where I asked this exact same question!

I only vaguely remember posting this, but I remember the person who answered me was much nicer and more detailed in his answer than he needed to be.  In retrospect, I'm a bit embarrassed that I posted this question instead of searching through the git history.  If everyone did what I did, open-source maintainers would be overwhelmed and would never get anything done.  I definitely don't recommend that you do what I did- instead, learn from my mistakes.  Github is not a 2nd StackOverflow.

It took multiple read-throughs of the issue at hand, spread out over many weeks, along with trial-and-error in the form of experimentation.  But **eventually** I was able to figure this out on my own, without relying on the above post.  If you've read this far and slogged through all my experiments with me, I'm confident you can do likewise.
