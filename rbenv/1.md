---
layout: default
title: Chapter 1- What's the first thing that happens when you type a Ruby command into the terminal and hit "Enter"?
permalink: /rbenv/ch-1
category: rbenv
id: 1
---

# Chapter 1- What's the first thing that happens when you type a Ruby command into the terminal and hit "Enter"?

This is the question which set me off on this entire project.

> (Note: the below walk-through is based on `rbenv` version `1.2.0-46-g52acbdf`.  You'll likely need to install that version and run `rbenv rehash` if you want to follow along on your own machine.  The git SHA for the code I'm analyzing is `c4395e58201966d9f90c12bd6b7342e389e7a4cb`, and you can find the Github repo for this version [here](c4395e58201966d9f90c12bd6b7342e389e7a4cb).)

One day I found myself curious about what happens when I type `bundle install` into my terminal and hit enter.  For those unfamiliar with this command, it comes from the [Bundler library](https://bundler.io/).  Bundler touts itself as providing "a consistent environment for Ruby projects by tracking and installing the exact gems and versions that are needed."

`bundle install` is one of the most common commands we find ourselves typing in Ruby, and I thought it'd be cool if I didn't find it so mysterious.  So I decided to take a look at the code and find out.

My first thought is to determine where the code for the `bundle` command lives.  To do that, let's use the â€˜which' UNIX command:

```
$ which bundle

~/.rbenv/shims/bundle

```

## Dotfiles and dot directories

This shows that file containing the `bundle` command's logic lives in a subdirectory of a directory called `.rbenv`.  The directory's name begins with a `.` because it's meant to be hidden from the `ls` command (unless you run `ls -a` instead of just `ls`).  In UNIX, there's [a convention](https://archive.ph/9l8sE) whereby the names of files and directories which are meant to be hidden from view by default are prefixed with a dot.

This hidden directory houses the logic for my Ruby version manager, which is called `rbenv`.  RBENV lets me switch between Ruby versions without too much hassle.  This is a useful ability, because I have many different Ruby codebases installed on my machine right now, and different codebases can depend on different versions of Ruby.

## Why version management matters

When you run a Rails program, under-the-hood Rails will need to call the `ruby` interpreter under the hood.  If you have multiple versions of Ruby installed, that means you have multiple Ruby interpreters installed.  Each of them uses the terminal command `ruby` to execute its logic.  Without a Ruby version manager to help us switch between versions, our OS will just pick the first version of the `ruby` command it finds.  In other words, the first Ruby interpreter it finds.  This "first version it finds" may or may not be the Ruby version we need.  A Ruby version manager like RBENV (or chruby or rvm or asdf or others) automatically ensures that every time we `cd` into a new Ruby project's directory, we're using the version that this project depends on.

At least in the case of RBENV (I'm not sure about those other version managers), one of the cool things we get is that not only do we cleanly switch between Ruby versions, but we avoid conflicts with our [Ruby gems](https://archive.ph/yVGxn).  Imagine the following scenario:

 - You have a folder containing two Ruby projects, one of which depended on Ruby version 3.0 (let's call this project "Ruby A") and another which depended on Ruby version 2.7.0 (here, "Ruby B").
 - Each project contains the `foobar` gem.  Ruby A depends on `foobar` version 1.0, while Ruby B depends on `foobar` 2.0.
 - You decide not to manage your Ruby versions with a version manager.
 - Therefore, you only have one Ruby interpreter, and one directory on your laptop where your gems are installed.

 In this scenario, when you `cd` back and forth between Ruby A and Ruby B in order to work on one or the other, how does your laptop know what you mean when you type `ruby project_a.rb`?  Do you mean the Ruby interpreter for v3.0 or the one for v2.7.0?  And when the interpreter encounters the Foobar class in your Ruby code, should it use the class from v1.0 of the `foobar` gem, or the class from v2.0?

 Without a Ruby version manager to orchestrate this for you, every time you wanted to switch from working on Ruby A to Ruby B (or vice-versa), you'd have to un-install the incorrect gem versions from the code you were just working on, and re-install the gem versions for the code you're about to work on.

 Each Ruby version manager solves this problem in a different way, but the thing they have in common is that they all handle this problem for you behind-the-scenes.  As we'll see, RBENV handles this by maintaining separate folders for each version of Ruby that you have installed.  Each of these Ruby folders contains a folder for all the gems you've installed *for that version of Ruby*.  It then cleanly switches between the various Ruby installations depending on how you've specified your Ruby version.  We'll get into different options for doing this later.

## Shims

RBENV accomplishes this task by *intercepting* the command you're running, deciding which Ruby version to use, and then passing the command you entered to the right interpreter based on that version.  The file which performs this interception is known as a "shim".  Programs that act as shims are meant to be transparent, meaning that you think you're talking to the gem, but the whole time you're really talking to the shim.  Similarly, the gem thinks it's talking to you, not to a shim.

The file whose path we discovered earlier (`~/.rbenv/shims/bundle`) is the shim file for the Bundle gem.

## The code for the shim file

Let's inspect the file from the above filepath a little more closely.

```
$ vim ~/.rbenv/shims/bundle
```

```
#!/usr/bin/env bash
set -e
[ -n "$RBENV_DEBUG" ] && set -x

program="${0##*/}"
if [ "$program" = "ruby" ]; then
  for arg; do
    case "$arg" in
    -e* | -- ) break ;;
    */* )
      if [ -f "$arg" ]; then
        export RBENV_DIR="${arg%/*}"
        break
      fi
      ;;
    esac
  done
fi

export RBENV_ROOT="~/.rbenv"
exec "~/.rbenv/bin/rbenv" exec "$program" "$@"
```

Yikes!  That's a spicy meatball.  We'll need the balance of this post to explain it all in detail, but the important thing to remember is that the above code is NOT the code for the `bundle` command, but rather the code for RBENV's *shim* of the `bundle` command.  In fact, if you were to inspect other files in the `~/.rbenv/shims/` folder, you'd see they look *exactly* the same!  The following files all contain exactly the same code as the above:

 - `~/.rbenv/shims/rails`
 - `~/.rbenv/shims/ruby`
 - `~/.rbenv/shims/gem`

Let's break down the code line-by-line, and we'll see why all these files can have the same exact code, yet do drastically different things (depending on the command you're running).

## The shebang line

```
#!/usr/bin/env bash
```

Line 1 is called a ["shebang"](https://archive.ph/lO8UI).

In UNIX, a shebang is a special line of code at the top of a script file which tells UNIX which program to use in order to execute the code which comes after it.  In our case, since the above code is a bash script, we're telling UNIX to use bash to evaluate the code.

We *could* (hypothetically) leave the shebang out from this file.  But we have to tell UNIX  how to interpret the file (i.e. which interpreter to use).  If we don't do so in the file itself, we'd have to do so when we type the command into the terminal.  So instead of typing `bundle install` in the command line, we'd have to type the following every time:

```
/usr/bin/env bundle install
````

It's less about fewer keystrokes (although that's nice too), and more about ensuring the correct interpreter is used.

### Aside- `#!/usr/bin/env bash` vs. `#!/usr/bin/bash`

Note that you might sometimes see `#!/usr/bin/bash` instead of as a shebang, instead of `#!/usr/bin/env bash`.  The difference between the two is illustrated in further detail [here](https://archive.ph/ouudu) and [here](https://archive.ph/4jEZL).  But the gist of it is that `/usr/bin/env` checks your terminal environment for variables, sets them, and then runs your command.  If we type just `env`, we can see a list of the environment variables that `env` will set.

-------------

Note that "bash" is not the only interpreter we can tell UNIX to use for a script that we write.  The only reason the code author used it here is because they wrote the subsequent code in bash.  If they had written it in Ruby, they could have written `#!/usr/bin/env ruby` instead (i.e. replace `bash` with `ruby` in the shebang).  In fact, let's try doing exactly that as an experiment.

### Experiment- writing a script with a Ruby shebang

We start by writing a regular Ruby script with a `.rb` file extension.  We'll call it "hello.rb":

```
# hello.rb

  1 puts "Hello world!"
```

When we run `ruby hello.rb` from the command line, we get:

```
$ ruby hello.rb

Hello world
```

What happens if we don't use the `ruby` command, instead just running the file as if it were an executable?

```
$ ./hello.rb

zsh: permission denied: ./hello.rb
```

OK, well this is just because we haven't yet updated the file permissions to [make the file executable](https://askubuntu.com/questions/229589/how-to-make-a-file-e-g-a-sh-script-executable-so-it-can-be-run-from-a-termi).  That's a step we'll need to do whenever we make a brand-new file.  We do that with the `chmod` command, passing `+x` to tell UNIX to update the file's execution permission:

```
chmod +x hello.rb
```

Now that we've made the file executable, when we actually run it, we get:

```
$ ./hello.rb

./hello.rb: line 1: puts: command not found
```

Our error is telling us that UNIX doesn't recognize the command `puts`.  That's because `puts` is a Ruby command, and we haven't yet told bash that we want to use Ruby.

Lastly, let's add a Ruby-specific shebang to the top of the file:

```
  1 #!/usr/bin/env ruby
  2
  3 puts "Hello world"
```

Now, when we re-run the file, we get:

```
$ ./hello.rb

Hello world
```

Success!  We've told bash which interpreter we want to use, meaning that we no longer need to use the `ruby` command at the terminal prompt.

### Aside- why aren't new files executable by default?

I asked myself this same question, and I wasn't able to find an authoritative answer online.  My best guess is that it has to do with erring on the side of caution.

I use my personal computer as just that- a personal device (as opposed to sharing it with other people).  But back when UNIX was first invented, it was common for people to share a computer (both because they were much larger in size, and because they were more expensive).  And even today, there are likely many reasons why a group of people might choose to share a computer, and would therefore each need their own login to that computer.  After all, you wouldn't want to assume that all of those users would be comfortable sharing their files with each other, willy-nilly.

Therefore, on such a shared device, it's better to *have* the ability to grant/revoke read/write/execute permissions, than it is to *not* have that ability.  And it's safer to err on the side of restrictiveness (i.e. through files which are non-executable by default) vs. erring on the side of permissiveness.

TODO: I'd love some authoritative sources to fill in the blanks around the history of this UNIX design decision, as opposed to just "my best guess".

### Aside- Experiments

Above we saw our first experiment of this post.  We'll be using experiments a lot.  They'll help us construct hypotheses of how we think code might work, and then test whether those hypotheses are correct.

## The PATH variable

Going back to the environment variables which are loaded by `env`, an important example of these is the `PATH` variable.  It's important because it contains a list of directories that UNIX will search through, when it looks for the command we ask `env` to run (as well as the order in which the search will happen).  So if my shebang is `#!/usr/bin/env ruby`, and my `PATH` variable is:
```
~/.rbenv/shims:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin
```

...then UNIX will check for the `ruby` command in the following directories, in the order they appear below:

```
~/.rbenv/shims
/usr/local/sbin
/usr/local/bin
/usr/bin
/bin
```

As you may have guessed, the PATH string is a list of zero or more directories on your computer, concatenated together into a single string with the `:` character used as a delimiter.  Further down, we'll talk more about how UNIX splits the `PATH` string using this delimiter.

As soon as UNIX finds an executable file named `ruby`, it will stop checking the list of directories from `PATH`, and attempt to run that executable along with whatever flags or arguments were passed to it.

Let's move on to line 2.

## The `set` command


```
set -e
```

I've never seen the `set` command before, so we'll have to do some research here.

### Aside- how to look up a command we don't recognize

A good rule of thumb is to always look for the most authoritative, original source of truth possible.  Usually this means "reading the manual" (also sometimes known as "reading the f'ing manual").  In many cases, we can find the manual for various terminal commands using the `man` command.  If we fail to find what we're looking for using `man`, we can try checking StackOverflow or another source.  But the quality of those sources can vary widely, so a useful habit is to stick to official docs when we can.

### Experiment- looking up a `man` page

One terminal command that most of us are familiar with by now is `ls`, which prints out the contents of a directory.  Let's use that command as a springboard to help us learn about `man` pages.

If we type `man ls` in the terminal, we get:

<p style="text-align: center">
  <img src="/assets/images/man-ls.png" width="75%" alt="man entry for the ls command">
</p>

Here we can see:
 - the command's name and a brief description
 - a synopsis of the API (the order in which you'd type the command, its flags and args, etc.)
 - a longer description of the command itself (here, `operand` means "the arg you pass to `ls`")
 - an explanation of the command's possible arguments + flags, and what each one does

If we keep scrolling down the `man` page, we'll also see:

 - a list of environment variables which affect how `ls` works
 - a description of the exit code(s) that `ls` might return, and under what conditions they might be returned
 - examples of how to use the `ls` command
 - various other bits of information which aren't immediately relevant to us now

If you're not familiar with `man` pages, I recommend at least skimming the page for `ls`.

------------

Let's try looking up the above `set` command in its `man` page:

<p style="text-align: center">
  <img src="/assets/images/man-set.png" width="75%" alt="man entry for the set command">
</p>

This `man` page looks a bit different.  If we read it closely, we see that it doesn't describe the `set` command itself.  We don't see the `set` command specifically mentioned at the top, the way we did with `ls`.  Nor do we see the same synopsis or the other sections we saw last time.  Instead, it seems to describe something called the "General Commands Manual".  At first glance, this appears to be an explanation of what a builtin command is in UNIX, not an explanation of the command you're interested in.

Depending on the command you give it, sometimes `man` will give you documentation on that command (like it did with `ls`), while other times, it returns the above.  I was a bit confused on why this is.  I found an answer [here](https://unix.stackexchange.com/questions/167004/why-dont-shell-builtins-have-proper-man-pages).  The quote from the link which made it click for me was this:

<p style="text-align: center">
  <img src="/assets/images/builtin-manuals.png" width="75%" alt="man entries for builtin commands">
</p>

The gist of it is that `man` pages are provided only for commands which come from UNIX.  But `bash` is not UNIX.  UNIX is the operating system, and `bash` is the application we're using to interact with the operating system (aka [the "shell"](https://web.archive.org/web/20220601094544/https://www.pcmag.com/encyclopedia/term/shell) which surrounds the operating system).  There are many such applications- other examples include "zsh", "fish", etc.  Later on, we'll actually encounter these two shells again, when we dive into specific `rbenv` commands.

Each of these shells has its own set of commands, its own syntax, etc.  Some shells (such as `bash` and `zsh`) are quite similar to each other (in terms of the commands they offer).  Others (such as `bash` vs. `fish`) are *very* different from each other.  And it's certainly possible that one day you'll decide to switch from one shell to another.   If that happens, you'll want to know which commands you can rely on to be there in your new environment, and which ones may have disappeared.

Therefore, it's important to distinguish which commands are available in all shells from those which are only available in certain shells.  One way we do that is by putting the documentation for UNIX commands in one folder (accessible via the `man` command), and docs for the shell-specific commands (these are called "builtins") in another folder (accessible via the `help` command in `bash`, or via `run-help` in `zsh` with some extra configuration; see below).

It would be misleading to include manual files for each shell's commands in the same folder that we use to include the manuals for the operating system's commands.  So the shell authors keep the docs for their commands separate.

Moral of the story- if you ever see the  "General Commands Manual" thing when looking up a `man` page, the command you're looking up is a *shell builtin*, not a UNIX command.

### Experiment- which shell are you using?

I'm typing this on a 2019 Macbook Pro, [which ships with `zsh` as its default shell](https://archive.ph/QGwEP).  You're likely working on a machine with non-trivial differences from mine, and your default shell might be `bash` or even something else.

To find out, open your terminal and type the following command:

```
$ echo "$0"
```

When I do this, I see:

```
$ echo "$0"

-zsh
```

We see `-zsh` as the output, telling us that our current shell is `zsh`.

Now, when I open up a `bash` terminal *from* my `zsh` terminal and repeat this, I see the following:

```
$ bash

...

bash-3.2$ echo "$0"

bash
```

Now see `bash`!

Note that you might also see advice online about using the `$SHELL` environment variable, like so:

```
echo "$SHELL"
```

When I do this on my machine, I see:

```
$ echo "$SHELL"

/bin/zsh
```

That's easier to read and should work fine in most cases.  The only reason I went with the `echo "$0"` command above is that I wanted the ability to open up `bash` **from `zsh`** and see `bash`, for the purposes of the demonstration.  If I were to do this with `echo "$SHELL"`, I would continue to see `zsh`, even though we're now in a `bash` shell:

```
bash-3.2$ echo "$SHELL"

/bin/zsh
```

That's because `$SHELL` returns the current user's default shell, **not** the shell that the user is currently using.  But if you're using that default shell (which you likely will be in most cases), you should be fine using `$SHELL`.

-----------

### Aside- making `help` easier to work with in `zsh`

I try to pull up the `help` docs for `set` to find out more about this command.

In a regular `bash` (i.e. not `zsh`) terminal, typing `help set` offers an explanation of the `set` command:

<p style="text-align: center">
  <img src="/assets/images/bash-help-set.png" width="75%" alt="displayed output for `help set` command in bash">
</p>

On the other hand, typing `help set` into `zsh` displays that `General Commands Manual`, which we've already seen.

Constantly encountering the `General Commands Manual` thing every time I want to look up a command is gonna get annoying.

I could configure my laptop to make `bash` the default shell for my machine.  After all, even though `zsh` is now the default for Macbooks, `bash` is also quite common, perhaps even more common worldwide than `zsh`.  This means that quite a few StackOverflow (and other) posts that I will encounter will assume I'm using `bash`.

However, that feels like overkill.  After some Googling around, I found [this StackOverflow question](https://superuser.com/questions/1563825/is-there-a-zsh-equivalent-to-the-bash-help-builtin), with [this answer](https://superuser.com/a/1563859/300277):

<p style="text-align: center">
  <img src="/assets/images/run-help-override.png" width="75%" alt="StackOverflow answer for how to configure the help command in zsh">
</p>

It appears to be telling me to:

 - unset any current definition of the `run-help` command
 - [autoload](https://stackoverflow.com/a/63661686/2143275) a new implementation of the `run-help` command
 - reset `HELPDIR` (the environment variable containing the path where `zsh` will search for helpfiles)
 - create an alias for our new `run-help` command, called `help`

The `run-help` command is a `zsh` command that is meant to show you documentation for `zsh`-specific commands (TODO- get proof of this claim).  Essentially what we're doing here is loading `run-help` into our shell, telling it the directory where the docs for the `zsh` commands can be found, and aliasing the `help` command to this `run-help` command (so that we can just type `help` instead of the full `run-help`).

This all sounds fine, so I add the code from StackOverflow into my `~/.zshrc` file:

<p style="text-align: center">
  <img src="/assets/images/zshrc.png" width="75%" alt="code in ~/.zshrc file">
</p>

I then run `source ~/.zshrc` to reload the file into memory (TODO- what is `~/.zshrc`?):

## Finally getting some answers on `set`

Now I'm able to re-run `help set` from the same terminal window and get a definition:

<p style="text-align: center">
  <img src="/assets/images/zsh-help-set.png" width="75%" alt="successful `help set` output">
</p>

This is great.  IMHO it's a bit less-readable than the output of the `man ls` command, BUT at least now I can see the original source of truth for builtin commands, despite using `zsh` instead of `bash`.

From the first paragraph, I see an explanation of the `-s` flag, and then I see:

```
For the meaning of the other flags, see zshoptions(1).
```

It's telling me that I need to use another command in order to read about the flags for zsh.  But what's with that `(1)` syntax at the end of the command?  Is that part of what I'm supposed to type?

Although I'm not confident that this will work, I try typing `zshoptions(1)` in my terminal, since that appears to be the syntax I'm meant to use.  Sure enough, that fails:

```
$ zshoptions(1)
zsh: unknown file attribute: 1
```

What about just "zshoptions"?

```
$ zshoptions
zsh: command not found: zshoptions
```

Welp, I'm out of ideas.  Feels like I'm banging my head against a wall here.  What is "zshoptions", and why is the helpfile telling me to use it?

I try Googling "command not found: zshoptions".  One of the first results I see is [this link](https://archive.ph/QGwEP).  Opening up that link, I read "You can find a full list of zsh options in the zsh Manual or with man zshoptions".

OK, so I'm supposed to type `man zshoptions` in the terminal?  Then I guess I'm confused what the `(1)` at the end of `zshoptions(1)` means.  I Google "what is the parentheses number in man bash" and find [this link](https://web.archive.org/web/20230209205725/https://stackoverflow.com/questions/62936/what-does-the-number-in-parentheses-shown-after-unix-command-names-in-manpages-m) with the following answer...

<p style="text-align: center">
  <img src="/assets/images/man-num-parentheses-1.png" width="75%" alt="what are the parentheses in a `man` title">
</p>

...followed by this additional answer:

<p style="text-align: center">
  <img src="/assets/images/man-num-parentheses-2.png" width="75%" alt="what are the parentheses in a `man` title">
</p>

Cool, so those numbers indicate which section of the UNIX manual the docs can be found in.  Also, it's possible to specify a certain section if a command by a certain name appears in more than one section.

Continuing onward... typing `man zshoptions` has a ton of output to parse.  Luckily, I happen to know a trick to find what I'm looking for: typing `/` puts me into search mode in the `man` output (similar to the `vim` editor program).  Typing `-e` as a search string from this search mode shows me the first occurrence of said search string, and hitting `n` (for `next`) shows me the subsequent occurrences until I find the flag I'm looking for.  That takes me to this section:

<p style="text-align: center">
  <img src="/assets/images/set-e.png" width="75%" alt="search for `-e`">
</p>

The important text seems to be "If a command has a non-zero exit status, execute the ZERR trap, if set, and exit."  The text after this first sentence might be helpful to my understanding, but it seems to require some knowledge that I don't yet possess, so I decide to skip it.  (By the way, we'll dive more deeply into exit statuses and their meaning a bit later, but if you want answers now, check out [this link](https://archive.ph/nCzoq) from The Linux Documentation Project.  For now don't worry about "ZERR traps", although if you're curious, you can find more info on traps [here](https://archive.ph/50n41).)

Back to the first sentence, I interpret it to mean that, if you add `set -e` to your bash script and an error occurs, the program exits immediately, as opposed to continuing on with the execution.  OK, but... isn't that what happens anyway?  That's certainly what I see when I write a Ruby script and an error occurs.  Is the helpfile implying that a program would just continue executing if you *leave out* `set -e` and an error occurs?

Let's try an experiment to figure out whether that's the case.

### Experiment- will `set -e` cause a script to stop when an error is raised?

I make 2 bash scripts, one called `foo` and one called `bar`:

`foo` looks like so:

```
  1 #!/usr/bin/env bash
  2
  3 set -e
  4
  5 ./bar
  6
  7 echo "foo ran successfully"
```

It does the following:

 - declares the script as a `bash` script
 - calls `set -e` in the theory that this will cause any error to prevent the script from continuing
 - runs the `./bar` script, and
 - prints a summary line

In theory, if an error occurs when running `./bar`, our execution should stop and we shouldn't see "foo ran successfully" as output.

Meanwhile, `bar` looks like so:

```
  1 #!/usr/bin/env bash
  2
  3 echo "Inside bar; about to crash..."
  4
  5 exit 1
```

It does the following:

 - declares the script as a `bash` script (just like in foo)
 - prints a logline to STDOUT, and
 - triggers a non-zero exit code (i.e. an error)

I had prior knowledge of `exit 1`, `exit 0`, etc., which is how I knew to leverage them to produce the desired result here.  If this is the first time you're encountering the concept of exit codes, we'll talk more about them eventually, but for now [here](https://web.archive.org/web/20230202185938/https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html) are the GNU docs on exit codes.

I run `chmod +x` on both of these scripts, to make sure they're executable.  Then I run `./foo` in my terminal:

```
$ ./foo

Inside bar; about to crash...
```

OK, so we didn't see the summary line from `foo` printed to the screen.  To me, this indicates that the execution inside `foo` halted once the `bar` script ran into the non-zero exit code.

Now I comment out `set -e` from `foo`:

<p style="text-align: center">
  <img src="/assets/images/commented-set-e.png" width="50%" alt="a commented-out `set -e` command">
</p>

Now when I re-run `./foo`, I see the following:

```
$ ./foo

Inside bar; about to crash...
foo ran successfully
```

This time, I *do* see the summary logline from `foo`.  This tells me that the script's execution continues, even though we're still getting the same non-zero exit code from the `bar` script.

Based on this experiment, I think we can conclude that `set -e` does, in fact, prevent execution from continuing when the script encounters an error.

### Aside- why isn't `set -e` the default?

But my earlier question remains- why must a developer explicitly include `set -e` in their bash script?  Why is this not the default?  I highly doubt the answer to the above question will be found in the `man` or `help` pages, so I decide to cheat by using StackOverflow.

There, I find [these](https://stackoverflow.com/questions/13468481/when-to-use-set-e) [two](https://serverfault.com/questions/143445/what-does-set-e-do-and-why-might-it-be-considered-dangerous) posted questions.  From reading the answers, I gather that there are valid reasons for not using `set -e`, including the ability to catch and handle different errors in different ways:

<p style="text-align: center">
  <img src="/assets/images/set-e-default.png" width="75%" alt="why is `set -e` not the default?">
</p>

Therefore, the reason `set -e` is not the default is *probably* because the UNIX authors wanted to give script writers more fine-grained control over whether and how to handle different kinds of exceptions.  `set -e` lets you halt your program immediately whenever any kind of error is triggered, so you don't have to explicitly catch each kind of error separately.  Some people like to use it and some people don't; it appears to be a matter of preference.

Moving on to line 3 of the code.

{% include convert_kit_1.html %}

## Tests and conditions

```
[ -n "$RBENV_DEBUG" ] && set -x
```

What do those brackets mean?  [This answer](https://stackoverflow.com/a/2188369/2143275) from StackOverflow says:

<p style="text-align: center">
  <img src="/assets/images/what-are-brackets.png" width="75%" alt="What are brackets in bash?">
</p>

OK, so `[` and `test` are synonyms as far as `bash` is concerned.  I run `man test` and see the following:

<p style="text-align: center">
  <img src="/assets/images/man-test.png" width="75%" alt="`man` entry for the `test` command">
</p>

Here we have both the formal definition of `[` (aka `test`), as well as the meaning of the `-n` flag (at the bottom of the screenshot).  It looks like `[ -n "$RBENV_DEBUG" ]` returns a zero exit code (aka it returns "true") if the length of the string that it receives is greater than zero (i.e. if the string is *not* empty).  In this case, the string it receives is the value of the `RBENV_DEBUG` environment variable.

If this returns true, the `&&` syntax ensures that we then execute the 2nd half of this line of code: `set -x`.  We know about `set` already, but what does the `-x` flag do?  Using our new alias for `help`, we can run `help set` again and find out:


<p style="text-align: center">
  <img src="/assets/images/man-set.png" width="75%" alt="`man` entry for the `set` command">
</p>

Oh right, we have to use `man zshoptions` here:

<p style="text-align: center">
  <img src="/assets/images/man-zshoptions.png" width="75%" alt="`man` entry for the `zshoptions` command">
</p>

Using the `/` command from within `man zshoptions`, we type `-x` and keep hitting the `n` key until we see the following:

<p style="text-align: center">
  <img src="/assets/images/man-zshoptions-2.png" width="75%" alt="`man` entry for the `zshoptions` command">
</p>

There were a few other "hits" while searching for `-x` in `man zshoptions`, but they were either for the wrong case (i.e. the uppercase `-X` instead of the lowercase `-x`), or else were in the body of the description for another command (ex.- the description for `GLOBAL_EXPORT <Z>` contains a reference to `-x`, but does not tell us what `-x` does).

The `man` entry tells us that the `-x` flag causes `bash` to "(p)rint commands and their arguments as they are executed".  That kind of sounds to me like what "debug mode" or "verbose mode" does in many command line programs.  Which would make sense given the condition for the `test` command.

So to summarize, `[ -n "$RBENV_DEBUG" ] && set -x` tells us that we will print each command as it is executed if we set any non-empty string value for the `$RBENV_DEBUG` environment variable.  Cool!  Let's try an experiment or two:

### Experiment- `[` vs `test`

I create a file named `./foo`:

```
 if [ 5 == 5 ]; then
   echo "True"
 else
   echo "False"
 fi
```

I run `chmod +x foo` so I can execute the script, then `./foo`:
```
$ ./foo
True
```
I then update the script to use the `test` command instead of the square brackets, and repeat the experiment:

```
 if test 5 == 5; then
   echo "True"
 else
   echo "False"
 fi
```

Same results:

```
$ ./foo
True
```

At least in this case, `test` and `[ ... ]` appear to produce the same results.

-------------

Now what about that `-n` flag?

If we're looking for docs on a flag that we're supposed to pass to a certain command, we can usually find those docs inside the docs for the command itself.  In this case, I search for `-n` from the `man` page for `test`:

<p style="text-align: center">
  <img src="/assets/images/man-test-n.png" width="70%" alt="Documentation for the `test` command's `-n` flag">
</p>

So if the string we pass to `[ -n ... ]` has a length greater than zero, the `[ ... ]` condition will return true.

This line inspired me to try some experiments with the `[ -n ... ]` command.

### Experiment- the `-n` flag

From the `man` page for `test, [`, I see the following:

```
-n *string*     True if the length of *string* is nonzero.
```

With that in mind, first I ran the following:

```
$ export FOO='foo'

$ [ -n "$FOO" ] && echo "Hi"

"Hi"

$ [ -n "$BAR" ] && echo "Hi"

$ [ -n "" ] && echo "Hi"

```

This all works as expected.  Then, out of curiosity, I removed the double-quotes from `$BAR`:

```
$ [ -n $BAR ] && echo "Hi"
Hi
```

This was unexpected.  Since `$BAR` hadn't been set, I expected nothing to be printed to the screen.  I've read before that leaving the double-quotes off can cause unexpected behavior depending on what the variable value is set to.  But if it's not set to anything, I would expect its length to be zero, and therefore the statement to return false.

Lastly, I removed `$BAR` entirely:

```
$ [ -n ] && echo "Hi"
Hi
```

Since I don't pass any value at all to the flag, I would expect the length of the non-existent "string" to be zero.

Why are the last two cases not returning the results I expect?

In this case, [this StackOverflow post](https://archive.ph/x5AYq) comes through with an answer:

> `[ -n ]` does not use the `-n` test.
>
> The `-n` in `[ -n ]` is not a test at all. When there is only one argument between `[` and `]`, that argument is a string that is tested to see if it is empty. Even when that string has a leading `-`, it is still interpreted as an operand, not a test. Since the string `-n` is not empty (it contains two characters, `-` and `n`, not zero characters) `[ -n ]` evaluates to true.

...and [here](https://unix.stackexchange.com/a/141025/142469):

> You need to quote your variables. Without quotes you are writing `test -n` instead of `test -n <expression>`. The `test` command has no idea that you provided a variable that expanded to nothing.

OK great.  So when I don't use double-quotes, the script thinks I'm just running `[ -n ]`, which the interpreter interprets as an operand of length 2, which is why it returns true.  This is true whether I'm running `[ -n ]` or `[ -n $BAR ]`.

Another question about the bracket syntax: what would happen if I used single-quotes instead of double-quotes?  Does that matter?  Time for another simple experiment.

### Experiment- single- vs. double-qoutes

I update my "foo" script to include just the following:

```
$ echo "$FOO"

$ echo '$FOO'

```

When I run it, I get the following:

```
foo
$FOO
```

OK, so when using single-quotes instead of double-quotes, the shell doesn't expand the variable into its underlying value.  It just treats the variable name as the string you want to (in this case) echo to the terminal.

### Experiment- the `set -x` command

I write a new script, run `chmod +x` on it, and add the following code:

<p style="text-align: center">
  <img src="/assets/images/exp-set-x.png" width="30%" alt="Experiment script- `set -x`">
</p>

Side note- I found out from [this link](https://stackoverflow.com/questions/6348902/how-can-i-add-numbers-in-a-bash-script) that you add two integers in `bash` with the `$((...))` syntax.

As you can see, this script includes `set -x` at the top.  When I run this script, I see the following:

<p style="text-align: center">
  <img src="/assets/images/set-x-results.png" width="50%" alt="Results of a script with `set -x` included">
</p>

The lines with `+` in front of them appear to be the lines which are printed out *as a result of `set -x`*, while the lines without `+` are lines that would have printed out anyway (i.e. as a result of the `echo` commands I included in the script).

Now, when I comment out `set -x` and re-run the script, I see:

<p style="text-align: center">
  <img src="/assets/images/set-x-results-2.png" width="50%" alt="Results of the same script without `set -x`">
</p>

Now we don't see the `+` lines.

From this, I think we can conclude that `set -x` prints each line of code that is run, just as our docs described.

### Aside- shells

I haven't yet read a formal, official definition of what a "shell" really is.  That would be a good thing to do.

Here's [an article from PCMag](https://web.archive.org/web/20220601094544/https://www.pcmag.com/encyclopedia/term/shell), which describes a shell as "The outer layer of an operating system, otherwise known as the user interface."

To me, that's a super-clear, human-friendly explanation, and also clarifies why the term "shell" was chosen (a shell is "the outer layer" of an egg).

[Wikipedia](https://web.archive.org/web/20220730195425/https://en.wikipedia.org/wiki/Shell_(computing)) confirms this:

<p style="text-align: center">
  <img src="/assets/images/wiki-shell-definition.png" width="75%" alt="Wikipedia's definition of a computing shell">
</p>

### Aside- POSIX

One follow-up quote from the PCMag article:

  > "The term originally referred to the software that processed the commands typed into the Unix operating system. For example, the Bourne shell was the original Unix command line processor, and C shell and Korn shell were developed later."

Wait, but... if there are multiple different kinds of shell programs, doesn't that create a sort of "Wild West" situation where everyone implements commands in their own way?  Is there some sort of industry standard that all shells have to adhere to, to prevent chaos?

I Google "is there a standard for os shells", and the first result that comes up for me is [this link](https://archive.ph/Qr2UB), which includes the following quote:

> After careful research and testing, Bash shell was adopted as the standard for GNU/Linux. At the time of evaluation, Bash was found mostly compliant with the POSIX-1003.2 standard, and its maintainer demonstrated interest in bringing the shell to full compliance.

The phrase "mostly compliant with the POSIX-1003.2 standard" stands out.  I remember encountering the term "POSIX" in the past, and at the time I disregarded it because it wasn't relevant to me.  But at the moment, this seems like the most likely candidate for the standard I had in mind.

For confirmation, I Google "What is POSIX".  Even before I click on any search results, I see the following definition from Google's Dictionary feature:

<p style="text-align: center">
  <img src="/assets/images/what-is-posix-google.png" width="75%" alt="Google's definition for POSIX">
</p>

> a set of formal descriptions that provide a standard for the design of operating systems, especially ones which are compatible with Unix.

That sounds to me like what we're looking for!

### Aside- is it dangerous to rely on builtin commands?

Relatedly, while researching the `set` command, it dawned on me that if `man set` pulls up the "General Commands Manual", that must mean it's a builtin command (i.e. its implemented by a specific shell).  But RBENV is a widely-popular Ruby version manager, meaning it must be running on machines that use `bash`, but also machines that use `zsh` and other shells too.  Presumably all those shells implement `set`, but do they do so in the same way?  Is there any danger that the `set` command (and therefore RBENV) will behave differently in different shells?  More broadly, is it dangerous for a script to rely on built-ins, since they could be implemented differently in different shells?

I'm getting close to reaching my mental bandwidth limit for the day, so I decide to [post my question on StackOverflow](https://stackoverflow.com/questions/73447693/rbenv-is-it-risky-to-rely-on-builtin-shell-commands-such-as-set-since-builti).  A side benefit of this is that, in the past, just the act of writing out my question on StackOverflow has helped unblock me and helped me answer my own question, even when I don't end up posting it.

The next day, I see someone commented on my question:

```
As long as you stick to features from POSIX sh, you're usually pretty safe.
```

Googling for the phrase "POSIX docs", I find [the POSIX docs page](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_25) containing the `set` command, and verified that while it is considered a "special built-in", POSIX does have an opinion on its implementation:

```
If no options or arguments are specified, `set` shall write the names and values of all shell variables in the collation sequence of the current locale.
```

The use of the word "shall" seems to indicate that a shell is required to implement its version of `set` in the manner prescribed by POSIX if it wants to be considered POSIX-compliant.  This, I think, is enough to satisfy my question.

Note that I subsequently found [this blog article](https://archive.ph/JGREI), which seems to confirm my assumption that POSIX is the standard by which we can feel safe in using `set` in the rbenv shim.

### Aside- builtins vs keywords

While looking for more info on builtins, I came across the concept of shell "keywords".  And it got me wondering what the difference between these two things are.  Googling around a bit, it looks like I have my answer [here](https://archive.ph/Esst2).  TL;DR- a "builtin" is a method that you get for free from your shell.  The equivalent in Ruby would be "puts".  A "keyword" is a protected term, like "if" in Ruby.  It's not a method, the way "puts" is.

-------------

<!-- ### Aside- asking questions on StackOverflow

When I'm writing a question on StackOverflow, I try to make my chain of thought as clear as possible.  Whenever I make an assertion, I explain why and how I came to that conclusion.  For example, if I make a statement because I read it on another StackOverflow post, I'll link to that post (or even better, I'll link to the specific answer on that post).  Doing this helps people who are trying to answer my question to see how I reached my conclusion.  If they aren't able to do this, it's harder for them to correct me effectively if my assertion is mistaken.

I try to phrase my question as usefully as possible, adhering to the StackOverflow community guidelines on [how to ask a good question](https://archive.ph/EHVnj).  The people who answer questions are taking valuable time out of their day to help less-knowledgeable folks like me, and I want to respect their time.

Sticking to the above guidelines will usually result in a well-written question.  However, I am only human and, despite my best efforts, I will sometimes make mistakes.  I hope that my good-faith effort to ask an effective question will be clear to others, but sometimes I still get downvoted or called-out by folks who are in a less-than-sympathetic mood for whatever reason.  I'd be lying if I said I didn't care at all when that happens- upvotes feel good, after all.  But at the end of the day, if I've done everything I can to craft my question well, I'm willing to lose a few internet points if it means I'll gain a little knowledge. -->

Moving on to the next line of code:

```
program="${0##*/}"
```

## Parameter Expansion

Judging by the variable name, it looks like we're trying to store the name of the program.  Let's see whether we're right with an experiment.

### Experiment- are we storing the string we think we're storing?

I edit the shim file (`~/.rbenv/shims/bundle`) to echo the value of `program` after the above line of code:

```
...
program="${0##*/}"
echo "program name: $program"
...
```

Then I run the following:

<p style="text-align: center">
  <img src="/assets/images/echo-program.png" width="50%" alt="echo the contents of the `program` variable">
</p>

Don't worry about `Could not locate Gemfile`- that's what happens when you try to run the `bundle` command in a directory without a file named `Gemfile`.  The important thing is that it printed out `program name: bundle`.  When I remove my `echo` command, this no longer happens.

Just to be safe, I do the same experiment with the shim for the `ruby` command (i.e. `~/.rbenv/shims/ruby`):

```
program="${0##*/}"
echo "program name: $program"
```

Then I run:

<p style="text-align: center">
  <img src="/assets/images/echo-program-2.png" width="50%" alt="echo the contents of the `program` variable">
</p>

Same thing- it printed the name of the first command I entered into the terminal, followed by the expected output of the `ruby -e "puts 5+5"` command.  By this point, I am confident that `${0##*/}` evaluates to "bundle" in my case.

But what is this weird syntax which evaluates to the name of the program?  After Googling that exact string ("${0##*/}"), I find [this StackOverflow link](https://archive.ph/1wCki), which says:

<p style="text-align: center">
  <img src="/assets/images/param-expansion-example-1.png" width="50%" alt="parameter expansion- first example">
</p>

The author claims that `$0` will evaluate to the path of the file that we're executing.  Let's test that out.

### Experiment- messing around with parameter expansion

I create a directory named "foo", and inside of that a subdirectory also named "foo", and inside of that a file named "bar".  Inside of bar I type the following:

```
#!/usr/bin/env bash

echo "$0"
```

I have to modify the file's permissions so that I can execute it:

```
$ chmod +x ./foo/foo/bar
```

Now I execute it:

```
$ ./foo/foo/bar
./foo/foo/bar
```

Great, we verified that we can reproduce the `$0` behavior described in the StackOverflow post.

Based on the answer, I wondered whether wrapping `$0` in curly braces would change its output.  I tried this too:

```
#!/usr/bin/env bash

echo "${0}"
```

When I executed this updated version of `./foo/foo/bar`, it had the result I expected.

Now to test the 2nd part of the answer, about removing prefixes.  I'll first try the same syntax as in the StackOverflow answer (i.e. `##*/`):

```
#!/usr/bin/env bash

echo "${0##*/}"
```
When I run it:

```
$ ./foo/foo/bar
bar
```

So without the `##*/` syntax, we get `./foo/foo/bar` as our output.  With this new syntax, we get just `bar` as the output.

Out of curiosity, what happens when I remove one of the two "#" symbols?

```
#!/usr/bin/env bash

echo "${0#*/}"
```

Running it returns:

```
$ ./foo/foo/bar

foo/foo/bar
```

So instead of either `./foo/foo/bar` or `bar` as the output, now we get `foo/foo/bar`.

This is expected.  The StackOverflow answer mentions that only one `#` means it will stop after matching the first case of its search pattern.  In this case, our search pattern is the `*/` character, meaning the first `/` character plus anything before it.  So one `#` will cause `./` to be removed, while two `##` will cause `./foo/foo/` to be removed.

Now, instead of trying to remove forward slashes, what if I try to remove "foo"?

```
#!/usr/bin/env bash

echo "${0#*/foo}"
```

And executing it returns:

```
$ ./foo/foo/bar

/foo/bar
```

Great, it removed `./foo` as expected.  And adding back the 2nd `#`?

```
#!/usr/bin/env bash

echo "${0##*/foo}"
```

Running it returns:

```
$ ./foo/foo/bar

/bar
```

This time it removed `./foo/foo`, or both instances of the `*/foo` pattern.  I think we can call this experiment a success.

Lastly, going back to the concept that the StackOverflow answer mentioned, i.e. "parameter expansion".  I Google around a bit and find [this link](https://web.archive.org/web/20220816200045/https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html), which gives some examples and clarifies things a bit.

I feel like my understanding of the parameter expansion is good enough for now.  Next line of code.

## Conditional statements

```
if [ "$program" = "ruby" ]; then
...
fi
```

We already know what the bracket syntax does.  We also know we need double-quotes to expand our `program` variable safely.  And `if ... then` is one of the few bash commands which is readable to a layperson.  `fi` is just the way to close an `if` statement in `bash`.

So the purpose of this `if` check is to ensure the subsequent code only gets executed if the user typed `ruby` into the terminal as the program name.  Otherwise, nothing inside the `if` block gets executed.  Later, we'll examine that subsequent code and what it actually does.

The one thing that trips me up is the single equals sign.  In Ruby, we have to use double-equals to do a comparison, which appears to be whatâ€™s happening here.  But in bash, it looks like you can get away with single equals, as long as the comparison is wrapped in square brackets?  To see whether this is true, we'll do yet another experiment.

### Experiment- double- vs. single-equals comparison

I run the following experiment, in a new script file:

```
#!/usr/bin/env bash

program='ruby'
[ "$program" == "ruby" ] && echo "True"
```

When I `chmod` the file and run it, `True` prints out.  OK, so the double-equals sign does work in bash.  I then remove one of the equals signs and run it again, and the same thing happens.  So it seems like, in bash, the double- and single-equals syntaxes are equivalent.

To confirm this further, I Google "bash double vs single equals" and I find [this StackOverflow post](https://stackoverflow.com/questions/12948456/is-there-any-difference-between-and-operators-in-bash-or-sh):

<p style="text-align: center">
  <img src="/assets/images/equals-sign.png" width="70%" alt="the difference between = and == in bash">
</p>

Interestingly, I also try running the following directly in my terminal, without creating a whole new file (remember my terminal is zsh):

```
[ "$program" == "ruby" ] && echo "True"
zsh: = not found
```

So does that mean we canâ€™t use double-equals in zsh?

To answer this, I Google around a bit and find [this link](https://archive.ph/2iSkK) for a StackOverflow question titled:

<p style="text-align: center">
  <img src="/assets/images/title-of-so-question.png" width="70%" alt="title of so question">
</p>

Apparently in `zsh`,...

```
a == is a logical operator only inside [[ ... ]] constructs.
```

Iâ€™m pretty sure that "==" is an example of a "logical operator", so the above implies that I need to use double-brackets in my command.

So whatâ€™s the difference between single- and double-brackets?

## Double- vs. single-brackets

[This StackOverflow page](https://web.archive.org/web/20220602085208/https://serverfault.com/questions/52034/what-is-the-difference-between-double-and-single-square-brackets-in-bash) provides some help:

<p style="text-align: center">
  <img src="/assets/images/brackets.png" width="70%" alt="bracket syntax in bash">
</p>

OK, so `[` is more POSIX-compliant than `[[`, therefore itâ€™s more portable across a wider array of machines.  `[[` is more modern and comes with some helpful updates, so it can sometimes be easier to use.  But if youâ€™re writing a script that will be used by many people and you canâ€™t predict which shell theyâ€™ll run it on, youâ€™re probably safer using `[`.

Tangent: Further down in that StackOverflow link, I subsequently discovered that I *can* use single-brackets, but I have to wrap my double-equals sign in quotes, like this:

```
[ "$program" '==' "ruby" ] && echo "True"
True

```

Double-quotes worked as well, for what it's worth.


## IFS and delimiters

From prior knowledge, I happen to know that UNIX uses an environment variable named "IFS", which stands for "internal field separator".  That's the `IFS` which the above StackOverflow answer is referring to.  Here's [a link](https://web.archive.org/web/20220715010436/https://www.baeldung.com/linux/ifs-shell-variable) with more info.  `IFS` basically means "delimiter", i.e. a character or characters that we use to separate fields in a concatenated string.  The link contains an experiment, which I've replicated below so we can see what they're useful for.

### Experiment- IFS and delimiters

Iâ€™ve modified their script to add a shebang to make sure it runs on my machine:

```
#!/usr/bin/env bash

string="foo bar baz"

for i in $string
do
  echo "'$i' is the substring"
done
```
When I run the script, I see:

```
$ ./foo
'foo' is the substring
'bar' is the substring
'baz' is the substring
```

I then change the string declaration to:

```
string="foo:bar:baz"
```

When I re-run the script, I get:
```
$ ./foo
'foo:bar:baz' is the substring
```

Lastly, I re-define the `IFS` env var like so:

```
IFS=":"
```

When I re-run the script, I get:
```
$ ./foo
'foo' is the substring
'bar' is the substring
'baz' is the substring
```

This illustrates that the empty-space character " " was the default internal field separator on my machine.  Replacing ` ` with `:` in *both* the string and the `IFS` variable resulted in the same output, but making that same change in only the string *or* the variable would result in a single line of output, rather than 3 separate lines.

This experiment also shows that iterating over a string is similar to iterating over an array, where the items in the array are equivalent to the items in the string separated by the value of `$IFS`.  So if, like my machine, yours uses the " " character, then a string like "foo bar baz" (with 3 words and two spaces) will be separated into 3 separate strings ("foo", "bar", and "baz") for the purposes of iteration.

Moving onto the next line of code.

## for-loops in bash

```
  for arg; do

  ...

  done
```
This oneâ€™s a bit weird: up to this point, we haven't seen the `arg` variable explicitly defined by the code.  If we haven't seen this variable defined yet, that implies that itâ€™s defined or built-in by the language.  As usual, Googling turns up [a StackOverflow post](https://archive.ph/p4Cjp):

<p style="text-align: center">
  <img src="/assets/images/arg-for-loop.png" width="70%" alt="What is `arg` in a bash `for` loop?">
</p>

Scrolling down in the answer a bit, we see:

<p style="text-align: center">
  <img src="/assets/images/arg-for-loop-2.png" width="70%" alt="Omitting `in` in a bash `for` loop?">
</p>

The above statement implies that `$@` expands to the list of arguments provided to the script.  Letâ€™s see if thatâ€™s true with another experiment.

### Experiment- what does `$@` evaluate to?

I write a new script (again named simply "foo"):

```
#!/usr/bin/env bash

echo "$@"
```

Running the script with some random arguments, we get:

```
$ ./foo bar baz buzz

bar baz buzz
```

Changing the script a bit:

```
#!/usr/bin/env bash

for arg in "$@";
do
  echo "$arg"
done
```

Running this, we get:

```
$ ./foo bar baz buzz
bar
baz
buzz
```
And finally, testing whether we can eliminate `in "$@"`:

```
#!/usr/bin/env bash

for arg;
do
  echo "$arg"
done
```
Running this results in:

```
$ ./foo bar baz buzz
bar
baz
buzz
```

Awesome!  So we learned:

 - `$@` stands for the arguments that you pass to the script
 - If you write a `for` loop but leave off the `in ___` part, bash defaults to using `$@`

Moving on to the next line:

## Case statements

```
case "$arg" in
...
esac
```

I've seen case statements before (Ruby has them, as well), but I still feel like familiarizing myself with any bash-specific idiosyncracies.

I find [this link](https://web.archive.org/web/20220820011836/https://linuxize.com/post/bash-case-statement/), which explains bashâ€™s case statement syntax.  I would have preferred a more official link, but as of 25 Aug 2022 the official docs donâ€™t show up on page 1 of the search results.  At any rate, here are the highlights:


1. Each `case` statement starts with the `case` keyword, followed by the case expression and the `in` keyword. The statement ends with the `esac` keyword.

1. You can use multiple patterns separated by the `|` operator. The `)` operator terminates a pattern list.

1. A pattern can have [special characters](https://web.archive.org/web/20220820011901/https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html).

1. A pattern and its associated commands are known as a clause.

1. Each clause must be terminated with `;;`.

1. The commands corresponding to the first pattern that matches the expression are executed.

1. It is a common practice to use the wildcard asterisk symbol (`*`) as a final pattern to define the default case. This pattern will always match.

1. If no pattern is matched, the return status is zero. Otherwise, the return status is the [exit status](https://web.archive.org/web/20220806222213/https://linuxize.com/post/bash-exit/) of the executed commands.

The above bullet points also help clarify the syntax of the subsequent line, which is a condition that the case statement will match against:

```
    -e* | -- ) break ;;
    ...
```

Here we see multiple patterns separated by the `|` character, then terminated by the `)` character, as mentioned in bullet point 2 above.  The two conditions are `-e*` and `--`.  If the current arg in the iteration matches either pattern, we exit the `for` loop (i.e. we `break`).

Because of point #7 above, I suspect that any text starting with `-e` would fit the `-e*` pattern, and to prove it, I perform an experiment.

### Experiment- the `-e*` flag in a case statement

I write the following script:

```
#!/usr/bin/env bash

for arg; do
  case "$arg" in
    -e* ) echo "Boom!"
    break ;;
    * )
      echo "$arg" ;;
  esac
done

echo "Outside the for loop"
```

This is a simplified version of the original case statement.  It iterates over the args, and if an arg matches `-e*`, we echo a test string ("Boom!") and break out of the loop.  Otherwise, we just echo the arg itself and keep iterating.  When weâ€™re done with all the args in the loop, we echo "Outside the for loop" to indicate that the script is finished.

I then run the following:

```
$ ./foo bar -ebaz buzz
bar
Boom!
Outside the for loop
```

So we printed our first arg, and then "Boom!", then we did *not* print the third arg.  This is because "-ebaz" starts with "-e", which matched the "Boom!" condition of `-e*`.  Lastly, we printed "Outside the for loop" to prove that `break`ing doesnâ€™t result in an exit of the entire script.  Based on this result, I think we can safely say that we were correct, and the `-e*` flag returns true if a given string starts with `-e`, regardless of what follows after.

To figure out what the `-e` flag actually does, I just ran `ruby â€“help` and searched for the `-e` entry.  This flag lets you execute Ruby code directly in your terminal, without having to pass a filename to the Ruby interpreter.  For example:

```
$ ruby -e "puts 'Hello'"
Hello
```

So the `-e` flag is one of the two flags which will cause `rbenv` to assume that any subsequent args are meant to be positional args, not flags to the `ruby` command itself.

Regarding the 2nd pattern (`--`), Iâ€™ve seen it used in terminal commands before but I doubt I could explain its purpose.  StackOverflow [saves the day again](https://web.archive.org/web/20220623104640/https://unix.stackexchange.com/questions/11376/what-does-double-dash-mean):

<p style="text-align: center">
  <img src="/assets/images/double-dash.png" width="70%" alt="What is a double-dash?">
</p>

So everything before `--` is meant to be a flag of some sort (depending on the terminal command youâ€™re running) and everything after that is an argument to the script itself.  Hmmm OK, but you still need to be able to process the subsequent arguments in the script, right?  In our case, if the text matches the `--` pattern, does that mean the script breaks out of the list of args, meaning we wonâ€™t process anything after `--`?

Not quite.  The last line of the script makes use of `"$@"` again, specifically to pass those args to `$program`.  So we donâ€™t *completely* ignore the positional args.

## More pattern-matching with case statements

Next line of code:

```
    */* )
      ...
      ;;

```

Judging by the `)` terminator character and the `;;` a few lines down, this looks like another pattern that the case statement will match against.  The only thing that throws me off is the difference between the above pattern (`*/* )`) and the one in my experiment script (`* )`), which I borrowed from the link on case statements.  It looks like itâ€™s searching for a forward-slash, with zero or more characters before and/or after it.  In other words, most likely a file path.  Letâ€™s check that with an experiment.

### Experiment: how to check for a filepath in a case statement

I make a `bash` script which looks like so

```
#!/usr/bin/env bash

for arg; do
  case "$arg" in
    */* )
      echo "match: $arg";
    ;;
    * )
      echo "not a match: $arg";
    ;;
  esac
done
```

I then run the following in my terminal:

```
$ ./foo 1 2 3 a/b /b a/ / ''
not a match: 1
not a match: 2
not a match: 3
match: a/b
match: /b
match: a/
match: /
not a match:
```

So yes, it appears to be looking for strings which match the `/` symbol with zero or more characters of text on either side.  But how do we know itâ€™s a file?  The next line of code tells us.

## Detecting whether a string is a filepath

```
if [ -f "$arg" ]; then
...
fi
```

Running `man test` and searching for the `-f` string reveals the following:

<p style="text-align: center">
  <img src="/assets/images/man-test-f.png" width="70%" alt="What is the `-f` flag when passed inside brackets?">
</p>

> True if file exists and is a regular file.

So our case statement matches if the arg *could be* a filepath, and we further check this by using `[ -f "$arg" ]` to verify that it *actually is* a filepath.

FWIW, I'm guessing they say "regular file" here in order to distinguish from other types of files which are mentioned in other flag descriptions, such as "block special file" for the `-b` flag, and "character special file" for the `-c` flag.  In case you're wondering what these special files are all about, I found [this StackOverflow post](https://archive.ph/GVuaN) which appears to contain the answer.  I didn't spend too much time on this, however, because it doesn't look especially relevant to our goal here.

To test whether the `-f` flag behaves the way I think it does, I update my `foo` script to look like the following:

```
#!/usr/bin/env bash

for arg; do
  case "$arg" in
    */* )
      echo "match: $arg";
      if [ -f "$arg" ]; then
        echo "is definitely a filepath";
      else
        echo "turns out, is not a filepath";
      fi
    ;;
    * )
      echo "not a match: $arg";
    ;;
  esac
done
```

Then I run:

```
$ echo "bar" > bar
```

I run this command so that I have a file in my directory called `./bar`.

Lastly, I run the following:

```
$ ./foo 1 2 3 a/b /b a/ / '' ./bar foo

not a match: 1
not a match: 2
not a match: 3
match: a/b
turns out, is not a filepath
match: /b
turns out, is not a filepath
match: a/
turns out, is not a filepath
match: /
turns out, is not a filepath
not a match:
match: ./bar
is definitely a filepath
not a match: foo
```

As expected, the arguments which are known to *not* match a file in my current directory (i.e. `a/b`, `/b`, `a/`, and `/`) result in the output `turns out, is not a filepath`.  My `./bar` argument, which is known to match a file, results in the output `is definitely a filepath`.

But wait, the last argument (`foo`) *also* matches a filepath, i.e. the `./foo` script we're running!  It doesn't match because it doesn't have a `/` in its argument, but it *still is* a file.  Does that mean the RBENV shim is accidentally *skipping* some filepaths which it should be capturing?

Let's try an experiment which should tell us whether this is in fact happening with the shim for the `ruby` command.

### Experiment- are we skipping potentially valid filepaths?

I update the shim for my `ruby` command to look like the following:

<p style="text-align: center">
  <img src="/assets/images/new-ruby-shim.png" width="70%" alt="shim for `ruby` command with echo statements">
</p>

I then make a new file called `bar.rb`, which just contains the following:

```
puts 5+5
```

When I run `ruby bar.rb`, I see the following:

```
$ ruby bar.rb

arg: bar.rb
-----
10
```

However, when I run `ruby ./bar.rb`, I see the following:

```
$ ruby ./bar.rb

arg: ./bar.rb
arg matches */*: ./bar.rb
about to set RBENV_DIR for arg ./bar.rb
10
```

So adding `./` before `bar.rb` definitely causes additional code to be executed in our shim, above and beyond what gets executed when we pass only the filename **without** the relative directory path included.

Does this matter?

The answer to that is tied to what this case branch's purpose is.  We'll see what that is in the next section.

Before I move on, I make sure to delete the modifications I made to my `ruby` shim file.

## `export` statements

Next 2 lines of code are:

```
export RBENV_DIR="${arg%/*}"
break
```

Here we see that the purpose of our case statement is to set the `RBENV_DIR` environment variable, [which tells RBENV](https://github.com/rbenv/rbenv#environment-variables) where to start looking for a file called `.ruby-version`.  From [the RBENV docs](https://github.com/rbenv/rbenv#how-it-works), we can see that this file is one of the methods that RBENV uses to detect which Ruby version you want to use.

`export FOO=â€™barâ€™` creates a variable named `FOO` and sets its value to `bar`, **but** it does something else as well.  Weâ€™ve already seen variables declared earlier, i.e. `program="${0##*/}"`.  What does the use of `export` buy us?

[It turns out](https://web.archive.org/web/20220713174024/https://www.baeldung.com/linux/bash-variables-export) there are two kinds of variables in a bash script: a shell variable and an environment variable.  When we created the `program` variable, that was an example of creating a **shell** variable.  Shell variables are only accessible from within the shell theyâ€™re created in.  Environment variables, on the other hand, are accessible from within child shells created by the parent shell.

The blog post link above gives two examples, one demonstrating access of an environment variable from a child shell, and the other of accessing a shell variable from a child shell.  We can do an experiment in our terminal to see for ourselves.

### Experiment- environment vs shell variables

We can type the following directly in our terminal:

```
$ export MYVAR1=1729
$ MYVAR2=46
$ echo $MYVAR1
1729
$ echo $MYVAR2
46
$ bash    # Open a new child shell
bash $ echo $MYVAR1
1729
bash $ echo $MYVAR2

```

We can see here that `MYVAR1` is visible from within our new child shell, but `MYVAR2` is not.  That's because the declaration of `MYVAR1` was prefaced with `export`, while the declaration of `MYVAR2` was not.

So our current line of code creates an environment variable called `RBENV_DIR`, which will be available in child shells.  Whatâ€™s the value of the variable?  To answer that, we have to know what the following resolves to:

```
"${arg%/*}"
```

Letâ€™s try an experiment.

### Experiment- more fun with parameter expansion

Directly in my terminal, I type

```
$ arg="/foo/bar/baz"
$ bar="${arg%/*}"
$ echo $bar

/foo/bar
```

So `"${arg%/*}"` takes the argument, and trims off the last `/` character and everything after it.  This aligns with something I found earlier, in [the GNU docs](https://web.archive.org/web/20220816200045/https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html):

<p style="text-align: center">
  <img src="/assets/images/gnu-docs-param-expansion.png" width="70%" alt="GNU docs for parameter expansion">
</p>

As a reminder, the line of code that we're examining now is:

```
export RBENV_DIR="${arg%/*}"
```

So now we know enough to piece together what this line of code is doing.  It creates a new environment variable named `RBENV_DIR`, takes the directory of the (presumably) Ruby file that was passed to the `ruby` command, and sets the new env var equal to the *directory containing that Ruby file*.

This is a bit weird, though.  Based on its name, I would expect a variable named `RBENV_DIR` to point to the directory that `rbenv` is installed in, not the directory that contains the ruby file to be executed.

To learn how the `RBENV_DIR` env var is used, I search for it in the `rbenv` codebase on my local machine (which I've downloaded from [the Github repo](https://github.com/rbenv/rbenv/tree/c4395e58201966d9f90c12bd6b7342e389e7a4cb)).

Note that I search using the `ag` command, which you can learn how to install [here](https://github.com/ggreer/the_silver_searcher).  Your computer will likely ship with the `grep` command, but `ag` is *much* faster.

When I run this search, I see multiple references to it in various code files:

<p style="text-align: center">
  <img src="/assets/images/ag-rbenv-dir.png" width="70%" alt="Searching the rbenv codebase for RBENV_DIR">
</p>

The reference that catches my eye is in the README.md file, since this will likely tell me in plain English what I want to know:

<p style="text-align: center">
  <img src="/assets/images/rbenv-env-vars.png" width="70%" alt="Environment variables in RBENV">
</p>

So the intention is for `RBENV_DIR` to control where `rbenv` looks for your `.ruby-version` file.  This makes sense to me; I happen to know from experience that the `.ruby-version` file is one way that RBENV uses to detect which Ruby version you want to use.  Itâ€™s quite common, when running a Ruby file that depends on a specific Ruby version, to include a `.ruby-version` file in the same directory as the executed file.  This file contains the hard-coded version number that you want to use when running your Ruby script.

So to sum up what the code inside the `if` block does:

 - If the command youâ€™re running is the `ruby` command:
 - RBENV will iterate over each of the arguments you pass to the executed program
 - If the arg is `--` or if it starts with `-e`, it will immediately stop checking the remaining args.
 - if the argument looks like a file with a corresponding filepath attached, RBENV will check to see if that file exists.  If it does, it will grab the fileâ€™s parent directory and use that to (later on) check which Ruby version to use.

### Aside- my (possibly incorrect) understanding of why this matters

Let's combine what we learned about the current case branch with what we learned about the `RBENV_DIR` environment variable.  If you try to run a Ruby filepath from another directory outside of the directory you're in, RBENV will look for the `.ruby-version` file in *that* directory, which may have a `.ruby-version` file containing a different Ruby version from the one in the directory you're in now.  But if you only give the `ruby` command a certain filename with no parent directory / directories, then it looks for that filename in your current directory.

------------

The next line of code is pretty straight-forward:

```
export RBENV_ROOT="~/.rbenv"
```

## Setting `RBENV_ROOT`

This line of code just sets a 2nd environment variable named `RBENV_ROOT` to (in my case) the `.rbenv` hidden directory inside my home directory.  Referring back to the `README.md` file we just read, we see that this env var "Defines the directory under which Ruby versions and shims reside."  In other words, this env var does what I initially thought `RBENV_DIR` did.  Given this is an env var and not a shell var, we can assume that this variable might be used by a child process.

Next line of code:

```
exec "/usr/local/bin/rbenv" exec "$program" "$@"
```

## Executing the original gem

What does the `exec` command at the start of the line do?  I first try `man exec` but I get the "General Commands Manual", indicating that this is a builtin command.  I then try `help exec` and see:

```
$ help exec
exec [ -cl ] [ -a argv0 ] [ command [ arg ... ] ]
       Replace the current shell with command rather than forking.   If
       command  is  a  shell  builtin  command or a shell function, the
       shell executes it, and exits when the command is complete.
```

OK, so we're *replacing the current shell* with the command that we're running, "rather than forking".  It then, depending on certain conditions, may exit after the command is complete.

What does all that mean?

I have a feeling that I'm not going to get a plain-English explanation from the docs, so I search Google for "what is exec in bash".  One of the first links I find is from [ComputerHope](https://archive.ph/axmcj), which in the past I've found to provide readable, beginner-friendly answers to my questions:

<p style="text-align: center">
  <img src="/assets/images/what-is-exec.png" width="70%" alt="What is the `exec` bash command?">
</p>

OK... that still creates more questions than it answers:

 - What's a process?
 - What's the difference between forking a process and replacing the current process with the new one (i.e. what `exec` does)?
 - Why use `exec` over forking, or vice-versa?

## What is a process?

I Google "what is a process in unix" and find a few answers.  The first one is from [TechTarget.com](https://archive.ph/1gKHE):

<p style="text-align: center">
  <img src="/assets/images/what-is-a-process.png" width="70%" alt="What is a process in UNIX?">
</p>

So from this definition, we learned that:

 - "A process is an instance of a program running on your computer."
 - One process (the "parent process") can create a new process (the "child process").
 - The child process shares resources with the parent process.  I'm not yet sure what resources they mean.
 - If the parent process dies, the child process also dies.

Another useful link comes from [TheUnixSchool.com](https://archive.ph/0qS4Y):

<p style="text-align: center">
  <img src="/assets/images/what-is-a-process-2.png" width="70%" alt="What is a process in UNIX?">
</p>

From this link, we additionally learned that:

 - A process has properties associated with it, such as a PID, a PPID, etc.
 - `ps` is a command we can use to see which processes are currently running.

OK, I guess this helps somewhat.  But what's the difference between `exec`ing and `fork`ing?

[This StackOverflow answer](https://stackoverflow.com/a/1653415/2143275) is the best I've found so far in answering this question:

<p style="text-align: center">
  <img src="/assets/images/fork-vs-exec.png" width="70%" alt="What's the difference between `fork` and `exec`?">
</p>

It appears that, if you know the parent process will be done after running the child process, then `exec` is the way to go because you can re-use the parent's process ID instead of creating a new one.  On the other hand, if the parent still has work to do after the child finishes executing, then `fork` is the way to go.

One use case they give for `fork`ing (rather than `exec`ing) is a web server that needs one process to spin off and handle a request that the server receives, while the parent thread continues to listen for new requests in a separate process.

## Experiment- messing around with `exec`

Directly in my terminal, I run:

```
$ exec "/usr/bin/env" ruby -e "puts 5"
5

[Process completed]
```

Since "the shell exits when the command is complete", the final output I see in my terminal tab is `[Process completed]`, and I can no longer run any commands in this tab.  I have to close this tab and open a new one to resume entering commands in the terminal.

Next, I open a new tab and update my executable `./foo` script to read as follows:

```
#!/usr/bin/env bash

echo "PID of foo: $$"

./bar
```

I then update `./bar` to read as follows:

```
#!/usr/bin/env bash

echo "PID of bar: $$"
```

In `./foo`, I'm just calling `./bar` directly, with no `exec` beforehand.  I theorize this will default to a `fork`, and that the PID printed by `./foo` will be different from that printed by `./bar`.  I run `./foo` in my terminal and see the following:

```
$ ./foo

PID of foo: 57955
PID of bar: 57956
```

In this case, I was right!  Now, I update `./foo` to preface `./bar` with a call to `exec`:

```
#!/usr/bin/env bash

echo "PID of foo: $$"

exec ./bar
```

When I run it, I get:

```
$ ./foo

PID of foo: 58695
PID of bar: 58695
```

Now the PIDs are the same!

-------------

So thatâ€™s what the shell builtin `exec` command does.  But the line of code we're looking at is:

```
exec "/usr/local/bin/rbenv" exec ...
```

This means we're running the builtin `exec` command, and *passing it* the `rbenv exec` command.  What does `rbenv exec` do?

I check whether `rbenv exec` accepts a `--help` command:

```
$ rbenv exec --help
Usage: rbenv exec <command> [arg1 arg2...]

Runs an executable by first preparing PATH so that the selected Ruby
version's `bin' directory is at the front.

For example, if the currently selected Ruby version is 1.9.3-p327:
  rbenv exec bundle install

is equivalent to:
  PATH="$RBENV_ROOT/versions/1.9.3-p327/bin:$PATH" bundle install
```

So `rbenv exec` ensures that, when UNIX is checking `PATH` for a directory containing the command we entered, the first directory it finds is the one containing the version of Ruby you have set as your current version.  And because the shim file is where `rbenv exec` is called, the only thing we need to do is call the shim file.  Since the shim file always has the same name as the program itself, we don't have to change what we do at the commnd line.  We just do what we would have done anyway, which is type the name of our desired program!

**This is the heart of how RBENV ensures a clean separation of gem versions**- it separates Ruby versions (and their gems) into separate folders, and uses shims to intercept the calls you make to the Ruby programs you want to run.

## Summary - what we learned

 - What dotfiles and dot directories are
 - What version management is, and why it matters
 - What shims are
 - What a shebang is
 - What the `PATH` variable is, and how it's used
 - What the `set` command is, and how it's used
 - Using `set -e` to tell a `bash` script to exit immediately upon encountering an error
 - Using `set -x` to tell a `bash` script to run in verbose mode
 - How to look up documentation on our machine, using both the `man` and `help` commands
 - How to search the `man` and `help` pages if we're looking for a specific term
 - What a "shell" is
 - What POSIX is
 - What a "builtin" command is
 - How to find out which shell is your machine's default
 - How to form hypotheses on what our code does, and then run experiments to prove or disprove our hypotheses.
 - How to write boolean conditions in a shell script using the `[` or `test` command, as well as some useful flags for it (such as `-n` and `-f`).
 - How to conditionally execute arbitrary program logic based on the truthiness or falsiness of the above boolean conditions, using either `if` statements or `&&` one-liners.
 - What parameter expansion is, and some common use cases of it
 - double- vs. single-equals in a shell script
 - The difference between `[ ... ]` and `[[ ... ]]` in a shell script
 - What the internal field separator (aka `IFS`) is, and what it's useful for
 - How to iterate over arguments in a shell script, using a for-loop
 - Using the `$@` symbol to fetch the list of arguments provided to a script
 - How to write a case statement in `bash`
 - What `export` statements are, and why they're useful
 - The difference between shell variables and environment variables
 - The `exec` and `fork` commands, and when to use each one
 - What a "process" is

And possibly more, as well.  I lost count lol.

## But wait!

There are still quite a few unanswered questions!

 - OK, so we now know what this shim file is, but where did it come from?  How does RBENV generate a shim file for each of the Ruby programs I have installed?
 - I don't see a Ruby version number in the command `exec "/usr/local/bin/rbenv" exec "$program" "$@"`.  So the question remains- how does RBENV know which version number to use?
 -

These and more questions will be answered in the upcoming soup-to-nuts walk-through of the RBENV codebase.  By the end of the walk-through, we will have learned:

 - how common `bash` programs like `sed` and `awk` work.
 - most importantly: what to do when you feel like giving up.

Sign up below to get notified when those posts are released!
