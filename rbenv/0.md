---
layout: default
title: Introduction - How RBENV Shims Work
permalink: /rbenv/ch-0
category: rbenv
id: 0
---

# Introduction- How RBENV Shims Work

> (Note: the below walk-through is based on `rbenv` version `1.2.0-46-g52acbdf`.  You'll likely need to install that version and run `rbenv rehash` if you want to follow along on your own machine.  The git SHA for the code I'm analyzing is `c4395e58201966d9f90c12bd6b7342e389e7a4cb`, and you can find the Github repo for this version [here](c4395e58201966d9f90c12bd6b7342e389e7a4cb).)

------------

What's the first thing that happens when you type `bundle install` into the terminal and hit "Enter"?

This is the question which set me off on this entire project.

For those unfamiliar with this command, it comes from the [Bundler library](https://bundler.io/).  Bundler touts itself as providing "a consistent environment for Ruby projects by tracking and installing the exact gems and versions that are needed."

`bundle install` is one of the most common commands we find ourselves typing in Ruby, and I was frustrated that I didn't know how it worked.  I decided to take a look at the code and find out.

Ready?  Here we go!

----------

My first thought is to find out where (i.e. in which file) the code for the `bundle` command lives.  To do that, let's use the `which` UNIX command:

```
$ which bundle

~/.rbenv/shims/bundle
```

## Dotfiles and dot directories

This shows that file containing the `bundle` command's logic lives in a subdirectory of a directory called `.rbenv`.  The directory's name begins with a `.` because it's meant to be hidden from the `ls` command (unless you run `ls -a` instead of just `ls`).  In UNIX, there's [a convention](https://archive.ph/9l8sE) whereby the names of files and directories which are meant to be hidden from view by default are prefixed with a dot.

This hidden directory houses the logic for my Ruby version manager, which is called `rbenv`.  Not everyone uses RBENV; other people use `rvm`, `chruby`, `asdf`, or other programs.

RBENV lets me switch between Ruby versions without too much hassle.  This is a useful ability, because I have multiple Ruby codebases installed on my machine right now, and they all depend on different versions of Ruby.

## The pain that version managers solve

If you have multiple versions of Ruby installed, that means you have multiple Ruby interpreters installed.  [An interpreter](https://archive.ph/lmPhA) is a program which reads the file containing your code, and then executes the logic within.

Without a Ruby version manager to help us switch between versions, our OS will just pick the first interpreter (aka the first Ruby version) that it finds.  This "first version it finds" **might** be the right Ruby version that our program expects.  On the other hand, it **could** be an older version which doesn't yet have the methods, classes, etc.  **Or** it might be a newer version which has already deprecated the classes, methods, etc. that our program uses.  A Ruby version manager like RBENV (or chruby or rvm or asdf or others) automatically ensures that every time we `cd` into a new Ruby project's directory, we're using the version that this project depends on.

 Each Ruby version manager solves this problem in a different way, but the thing they have in common is that they all handle this problem for you behind-the-scenes.  As we'll see, RBENV handles this by maintaining separate folders for each version of Ruby that you have installed.  It then cleanly switches between the various Ruby installations depending on how you've specified your Ruby version.  We'll get into different options for doing this later.

## Shims

RBENV accomplishes the above task by **intercepting** the command you're running, deciding which Ruby version to use based on the information available to it (more on that later), and then passing the command you entered to the correct Ruby interpreter based on that version.  The file which performs this interception is known as a "shim".  Programs that act as shims are meant to be transparent, meaning that you think you're talking to the gem, but the whole time you're really talking to the shim.  Similarly, the gem thinks it's talking to you, not to a shim.

The file whose path we discovered earlier (`~/.rbenv/shims/bundle`) is the shim file for the Bundle gem.

## The code for the shim file

Let's take a look at the shim's code:

```
$ vim ~/.rbenv/shims/bundle
```

```
#!/usr/bin/env bash
set -e
[ -n "$RBENV_DEBUG" ] && set -x

program="${0##*/}"
if [ "$program" = "ruby" ]; then
  for arg; do
    case "$arg" in
    -e* | -- ) break ;;
    */* )
      if [ -f "$arg" ]; then
        export RBENV_DIR="${arg%/*}"
        break
      fi
      ;;
    esac
  done
fi

export RBENV_ROOT="/Users/myusername/.rbenv"
exec "/Users/myusername/.rbenv/bin/rbenv" exec "$program" "$@"
```

Yikes!  That's a spicy meatball.  We'll need the balance of this post to explain it all in detail, but the important thing to remember is that the above code does NOT come from the `bundle` command itself, but rather RBENV's *shim* of the `bundle` command.  In fact, if you were to inspect other files in the `~/.rbenv/shims/` folder, you'd see they look *exactly* the same!  The following files all contain exactly the same code as the above:

 - `~/.rbenv/shims/rails`
 - `~/.rbenv/shims/ruby`
 - `~/.rbenv/shims/gem`

Let's break down the code line-by-line, and we'll see why all these files can have the same exact code, yet execute drastically programs.

## The shebang line

```
#!/usr/bin/env bash
```

From a Google search for the string `"#!/usr/bin/env bash"`, I learned that this line of code is called a ["shebang"](https://archive.ph/lO8UI).

In UNIX, a shebang is a special line of code at the top of a script file which tells UNIX which program to use in order to execute the code which comes after it.  In this case, since the shebang ends in "bash", we're telling UNIX to use `bash` to evaluate the code.

We *could* (hypothetically) leave the shebang out from this file.  But somehow we have to tell UNIX  how to interpret the file (i.e. which interpreter to use).  If we don't do so in the file itself (i.e. by using a shebang), we'd have to do so when we type the command into the terminal.  So instead of typing `bundle install` in the command line, we'd have to type the following every time:

```
/usr/bin/env bundle install
````

or:

```
/bin/bash bundle install
````

It not only saves us a few keystrokes, but it's also one less thing that we humans can mess up when manually typing our command into the terminal.

### Aside- `#!/usr/bin/env bash` vs. `#!/usr/bin/bash`

Note that you might sometimes see `#!/usr/bin/bash` instead of as a shebang, instead of `#!/usr/bin/env bash`.  The difference between the two is illustrated in further detail [here](https://archive.ph/ouudu) and [here](https://archive.ph/4jEZL).  But the gist of it is that `/usr/bin/env` checks your terminal environment for variables, sets them, and then runs your command.  If we type just `env` into our terminals, we can see a list of the environment variables that `env` will set.

-------------

As I mentioned before, the string "bash" at the end of the shebang tells UNIX to use `bash` when interpreting the code which follows.  But `bash` is not the only interpreter we can tell UNIX to use for a script that we write.  The only reason the code author used it here is because they wrote the subsequent code in bash.  If they had written it in Ruby, they could have written `#!/usr/bin/env ruby` instead (i.e. replace `bash` with `ruby` in the shebang).  In fact, let's try doing exactly that, as an experiment.

### Experiment- writing a script with a Ruby shebang

We start by writing a regular Ruby script with a `.rb` file extension.  We'll call it "hello.rb":

```
# hello.rb

puts "Hello world!"
```

When we run `ruby hello.rb` from the command line, we get:

```
$ ruby hello.rb

Hello world
```

What happens if we don't use the `ruby` command, instead just running the file as if it were an executable?

```
$ ./hello.rb

zsh: permission denied: ./hello.rb
```

OK, well this is just because we haven't yet updated the file permissions to [make the file executable](https://askubuntu.com/questions/229589/how-to-make-a-file-e-g-a-sh-script-executable-so-it-can-be-run-from-a-termi).  That's a step we'll need to do whenever we make a brand-new file.  We do that with the `chmod` command, passing `+x` to tell UNIX to update the file's execution permission:

```
chmod +x hello.rb
```

Now that we've made the file executable, when we actually run it, we get:

```
$ ./hello.rb

./hello.rb: line 1: puts: command not found
```

Our error is telling us that UNIX doesn't recognize the command `puts`.  That's because `puts` is a Ruby command, and we haven't yet told UNIX that we want to use Ruby.

Lastly, let's add a Ruby-specific shebang to the top of the file:

```
  1 #!/usr/bin/env ruby
  2
  3 puts "Hello world"
```

Now, when we re-run the file, we get:

```
$ ./hello.rb

Hello world
```

Success!  We've told bash which interpreter we want to use, meaning that we no longer need to use the `ruby` command at the terminal prompt.

### Aside- why aren't new files executable by default?

I asked myself this same question, and I wasn't able to find an authoritative answer online.  My best guess is that it has to do with erring on the side of caution.

I use my personal computer as just that- a personal device (as opposed to sharing it with other people).  But back when UNIX was first invented, it was common for people to share a computer (both because they were much larger in size, and because they were more expensive).  And even today, there are likely many reasons why a group of people might choose to share a computer, and would therefore each need their own login to that computer.  After all, you wouldn't want to assume that all of those users would be comfortable sharing their files with each other, willy-nilly.

Therefore, on such a shared device, UNIX gives users the ability to either grant or revoke a given file's read/write/execute permissions.  And because UNIX needed to pick a default for when a file is first created, it erred on the side of caution by defaulting toward restrictiveness vs. permissiveness.

TODO: I'd love some authoritative sources to fill in the blanks around the history of this UNIX design decision, as opposed to just "my best guess".

### Aside- Experiments

We just did our first of many experiments.  These experiments will help us construct hypotheses of how we think code might work, and then test whether those hypotheses are correct.

## The PATH variable

Going back to the environment variables which are loaded by `env`, an important example of these is the `PATH` variable.  It's important because it contains a list of directories that UNIX will search through, when it looks for the command we ask `env` to run (as well as the order in which the search will happen).  So if my shebang is `#!/usr/bin/env ruby`, and my `PATH` variable looks like the following:
```
/Users/myusername/.rbenv/shims:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin
```

...then UNIX will check for the `ruby` command in the following directories, in the order they appear below:

```
/Users/myusername/.rbenv/shims
/usr/local/sbin
/usr/local/bin
/usr/bin
/bin
```

As you may have guessed, the `PATH` string is a list of directories on your computer, concatenated together into a single string with the `:` character used as a delimiter.  Further down, we'll talk more about how UNIX splits the `PATH` string using this delimiter.

As soon as UNIX finds an executable file named `ruby`, it will stop checking the list of directories from `PATH`, and attempt to run that executable along with whatever flags or arguments were passed to it.

Let's move on to line 2 of the shim file.

## The `set` command

```
set -e
```

I've never seen the `set` command before, so we'll have to do some research here.

### Aside- how to look up a command we don't recognize

When looking for the answer to a programming question, I want to avoid wild goose chases and time-wasting rabbit holes.  Usually, that means looking for the most authoritative, original source of truth that I can find.  If I can find the manual for the program whose command I'm researching, that's often my best bet.

In many cases, we can find the manual for various terminal commands using the `man` command.  If we fail to find what we're looking for using `man`, we can try checking StackOverflow or another source.  But the quality of those sources can vary widely, so a useful habit is to stick to official docs when we can.

### Experiment- looking up a `man` page

One terminal command that most of us are familiar with by now is `ls`, which prints out the contents of a directory.  Let's use that command as a springboard to help us learn about `man` pages.

If we type `man ls` in the terminal, we get:

<p style="text-align: center">
  <img src="/assets/images/man-ls.png" width="75%" alt="man entry for the ls command">
</p>

Here we can see:
 - the command's name and a brief description
 - a synopsis of the API (the order in which you'd type the command, its flags and args, etc.)
 - a longer description of the command itself (here, "operand" means "the arg you pass to `ls`")
 - an explanation of the command's possible arguments + flags, and what each one does

If we keep scrolling down the `man` page, we'll also see:

 - a list of environment variables which affect how `ls` works
 - a description of the exit code(s) that `ls` might return, and under what conditions they might be returned
 - examples of how to use the `ls` command
 - various other bits of information which aren't immediately relevant to us now

If you're not familiar with `man` pages, I recommend at least skimming the page for `ls`.

## Looking up the `man` page for `set`

Let's try looking up the above `set` command in its `man` page.  I type `man set` into my terminal and I see the following:

<p style="text-align: center">
  <img src="/assets/images/man-set.png" width="75%" alt="man entry for the set command">
</p>

This `man` page looks a bit different.  If we read it closely, we see that it doesn't describe the `set` command itself.  We don't see the `set` command specifically mentioned at the top, the way we did with `ls`.  Nor do we see the same synopsis or the other sections we saw last time.  Instead, it seems to describe something called the "General Commands Manual".

At first glance, this appears to be an explanation of what a builtin command is in UNIX, not an explanation of the command you're interested in.  As it turns out, depending on the command you give it, sometimes `man` will give you documentation on that command (like it did with `ls`), while other times, it returns the above.

So when does it give you one result, vs. the other?

I found an answer [here](https://unix.stackexchange.com/questions/167004/why-dont-shell-builtins-have-proper-man-pages).  The gist of it is that `man` pages are provided only for commands which come from UNIX.  But `bash` is not UNIX.  UNIX is the operating system, and `bash` is the application we're using to interact with the operating system (aka [the "shell"](https://web.archive.org/web/20220601094544/https://www.pcmag.com/encyclopedia/term/shell) which surrounds the operating system).

### Aside- shells

Here's [an article from PCMag](https://web.archive.org/web/20220601094544/https://www.pcmag.com/encyclopedia/term/shell), which describes a shell as "The outer layer of an operating system, otherwise known as the user interface."

To me, that's a super-clear, human-friendly explanation, and also clarifies why the term "shell" was chosen (a shell is "the outer layer" of an egg).

[Wikipedia](https://web.archive.org/web/20220730195425/https://en.wikipedia.org/wiki/Shell_(computing)) confirms this:

<p style="text-align: center">
  <img src="/assets/images/wiki-shell-definition.png" width="75%" alt="Wikipedia's definition of a computing shell">
</p>

There are many such applications- other examples include "zsh", "fish", etc.  Later on, we'll actually encounter these two shells again, when we dive into specific `rbenv` commands.

### Aside- builtins and keywords

While looking for more info on builtins, I came across the concept of shell "keywords".  And it got me wondering what the difference between these two things are.  Googling around a bit, it looks like I have my answer [here](https://archive.ph/Esst2).  TL;DR- a "builtin" is a method that you get for free from your shell.  The equivalent in Ruby would be "puts".  A "keyword" is a protected term, like "if" in Ruby.  It's not a method, the way "puts" is.  A "builtin" command is a command that is "built-in" to your *shell*, **not** your operating system.

### Aside- POSIX

One follow-up quote from the PCMag article:

  > "The term originally referred to the software that processed the commands typed into the Unix operating system. For example, the Bourne shell was the original Unix command line processor, and C shell and Korn shell were developed later."

Wait, but... if there are multiple different kinds of shell programs, doesn't that create a sort of "Wild West" situation where everyone implements commands in their own way?  Is there some sort of industry standard that all shells have to adhere to, to prevent chaos?

I Google "is there a standard for os shells", and the first result that comes up for me is [this link](https://archive.ph/Qr2UB), which includes the following quote:

> After careful research and testing, Bash shell was adopted as the standard for GNU/Linux. At the time of evaluation, Bash was found mostly compliant with the POSIX-1003.2 standard, and its maintainer demonstrated interest in bringing the shell to full compliance.

The phrase "mostly compliant with the POSIX-1003.2 standard" stands out.  I remember encountering the term "POSIX" in the past, and at the time I disregarded it because it wasn't relevant to me.  But at the moment, this seems like the most likely candidate for the standard I had in mind.

For confirmation, I Google "What is POSIX".  Even before I click on any search results, I see the following definition from Google's Dictionary feature:

<p style="text-align: center">
  <img src="/assets/images/what-is-posix-google.png" width="75%" alt="Google's definition for POSIX">
</p>

> a set of formal descriptions that provide a standard for the design of operating systems, especially ones which are compatible with Unix.

That sounds to me like what we're looking for!

## More about shells

Each shell has its own set of commands, its own syntax, etc.  Some shells (such as `bash` and `zsh`) are quite similar to each other (in terms of the commands they offer).  Others (such as `bash` vs. `fish`) are *very* different from each other.  And it's certainly possible that one day you'll decide to switch from one shell to another.   If that happens, you'll want to know which commands you can rely on to be there in your new environment, and which ones may have disappeared.

Therefore, it's important to distinguish which commands are available in all shells from those which are only available in certain shells.  One way we do that is by putting the documentation for UNIX commands in one folder (accessible via the `man` command), and docs for the shell-specific commands (these are called "builtins") in another folder (accessible via the `help` command in `bash`, or via `run-help` in `zsh` with some extra configuration; see below).

It would be misleading to include manual files for each shell's commands in the same folder that we use to include the manuals for the operating system's commands.  So the shell authors keep the docs for their commands separate.

Moral of the story- if you ever see the  "General Commands Manual" thing when looking up a `man` page, the command you're looking up is probably a *shell builtin*, not a UNIX command.

### Experiment- which shell are you using?

I'm typing this on a 2019 Macbook Pro, [which ships with `zsh` as its default shell](https://archive.ph/QGwEP).  Your default shell might be the same as mine, or it might `bash` or another shell.

To find out what it is, open your terminal and type the following command:

```
$ echo "$0"
```

When I do this, I see:

```
$ echo "$0"

-zsh
```

We see `-zsh` as the output, telling us that our current shell is `zsh`.

Now, when I open up a `bash` terminal *from* my `zsh` terminal and repeat this, I see the following:

```
$ bash

The default interactive shell is now zsh.
To update your account to use zsh, please run `chsh -s /bin/zsh`.
For more details, please visit https://support.apple.com/kb/HT208050.

bash-3.2$ echo "$0"

bash
```

Now see `bash`!

By the way, ignore the line that reads `The default interactive shell is now zsh.`  We know we're now in a `bash` terminal because:

 - the command prompt starts with `bash-3.2$`, and
 - more importantly, we saw "bash" when we `echo`'ed `"$0"`.

Note that you might also see advice online about using the `$SHELL` environment variable, like so:

```
echo "$SHELL"
```

When I exit out of my `bash` shell and type this on my machine from my original `zsh` shell, I see:

```
$ echo "$SHELL"

/bin/zsh
```

That's easier to read and should work fine in most cases.  The only reason I went with the `echo "$0"` command above is that I wanted the ability to open up `bash` **from `zsh`** and see `bash`, for the purposes of the demonstration.  If I were to do this with `echo "$SHELL"`, I would continue to see `zsh`, even though we're now in a `bash` shell:

```
bash-3.2$ echo "$SHELL"

/bin/zsh
```

That's because `$SHELL` returns the current user's default shell, **not** the shell that the user is currently using.  But if you're inside your default shell (which you likely will be in most cases), you should be fine using `$SHELL`.

-----------

### Aside- making `help` easier to work with in `zsh`

I try to pull up the `help` docs for `set` to find out more about this command.

In a regular `bash` (i.e. not `zsh`) terminal, typing `help set` offers an explanation of the `set` command:

<p style="text-align: center">
  <img src="/assets/images/bash-help-set.png" width="75%" alt="displayed output for `help set` command in bash">
</p>

On the other hand, typing `help set` into `zsh` displays that `General Commands Manual`, which we've already seen.

Constantly encountering the `General Commands Manual` screen every time I want to look up a command is starting to get annoying.

I could configure my laptop to make `bash` the default shell for my machine.  After all, even though `zsh` is now the default for Macbooks, `bash` is also quite common, perhaps even more common worldwide than `zsh`.  This means that quite a few StackOverflow (and other) posts that I will encounter will assume I'm using `bash`.

However, that feels like overkill.  After some Googling around, I found [this StackOverflow question](https://superuser.com/questions/1563825/is-there-a-zsh-equivalent-to-the-bash-help-builtin), with [this answer](https://superuser.com/a/1563859/300277):

<p style="text-align: center">
  <img src="/assets/images/run-help-override.png" width="75%" alt="StackOverflow answer for how to configure the help command in zsh">
</p>

It appears to be telling me to:

 - [unalias](https://archive.ph/4ek8N) the current definition of the `run-help` command ([which is aliased to `man` by default in `zsh`](https://archive.ph/cLX5h))
 - [autoload](https://stackoverflow.com/a/63661686/2143275) a new implementation of the `run-help` command
 - reset [`HELPDIR`](https://archive.ph/bFr1h) ("The HELPDIR parameter tells run-help where to look for the help files.")
 - create an alias for our new `run-help` command, called `help`

Essentially what we're doing here is loading `run-help` into our shell, telling it the directory where the docs for the `zsh` commands can be found, and aliasing the `help` command to this `run-help` command (so that we can just type `help` instead of the full `run-help`).

This all sounds fine, so I add the code from StackOverflow into my `~/.zshrc` file:

<p style="text-align: center">
  <img src="/assets/images/zshrc.png" width="75%" alt="code in ~/.zshrc file">
</p>

I then run `source ~/.zshrc` to reload the file into memory.

### Aside- what is a `.zshrc` file?

When you open a new terminal tab or window in `zsh`, one of the first things that happens is that `zsh` runs [a few setup scripts](https://archive.ph/KlEQ0).  One of these setup scripts is called `.zshrc`.  This file is where you'd put configuration options that you'd want to run on every new terminal tab or window.  This includes our `help` configuration, so that's why we add that code in `.zshrc`.

There are other files as well, such as `.zshenv`, but `.zshrc` is the one I interact with most.  Other shells have similar `rc` files (ex.- `bash` has `.bashrc`).  The `rc` in `.zshrc` stands for "run commands" or "run control", depending on [who you ask](https://archive.ph/r0z0j).

## Finally getting some answers on `set`

Back to the `set` command.

Now I'm able to re-run `help set` from the same terminal window and get a definition:

<p style="text-align: center">
  <img src="/assets/images/zsh-help-set.png" width="75%" alt="successful `help set` output">
</p>

This is great.  IMHO it's a bit less-readable than the output of the `man ls` command, BUT at least now I can see the original source of truth for builtin commands, despite using `zsh` instead of `bash`.

From the first paragraph, I see an explanation of the `-s` flag, and then I see:

```
For the meaning of the other flags, see zshoptions(1).
```

## `zshoptions`

It's telling me that I need to use another command in order to read about the flags for zsh.  But what's with that `(1)` syntax at the end of the command?  Is that part of what I'm supposed to type?

Although I'm pretty sure this won't work, I try typing `zshoptions(1)` in my terminal, since that **appears to be** the syntax I'm meant to use.  Sure enough, that fails:

```
$ zshoptions(1)
zsh: unknown file attribute: 1
```

What about just "zshoptions"?

```
$ zshoptions
zsh: command not found: zshoptions
```

Welp, I'm out of ideas.  Feels like I'm banging my head against a wall here.  What is "zshoptions", and why is the helpfile telling me to use it?

I try Googling "command not found: zshoptions".  One of the first results I see is [this link](https://archive.ph/QGwEP).  Opening up that link, I read "You can find a full list of zsh options in the zsh Manual or with man zshoptions".

OK, so I'm supposed to type `man zshoptions` in the terminal?  Then I guess I'm confused what the `(1)` at the end of `zshoptions(1)` means.

### Aside- section headers in `man` output

I Google "what is the parentheses number in man bash" and find [this link](https://web.archive.org/web/20230209205725/https://stackoverflow.com/questions/62936/what-does-the-number-in-parentheses-shown-after-unix-command-names-in-manpages-m) with the following answer...

<p style="text-align: center">
  <img src="/assets/images/man-num-parentheses-1.png" width="75%" alt="what are the parentheses in a `man` title">
</p>

...followed by this additional answer:

<p style="text-align: center">
  <img src="/assets/images/man-num-parentheses-2.png" width="75%" alt="what are the parentheses in a `man` title">
</p>

Cool, so those numbers indicate which section of the UNIX manual the docs can be found in.  Also, it's possible to specify a certain section if a command by a certain name appears in more than one section.

-----------

Continuing onward... typing `man zshoptions` has a ton of output to parse.  Luckily, I happen to know a trick to find what I'm looking for: typing `/` puts me into search mode in the `man` output (similar to the `vim` editor program, if you're familiar with that; if not, don't worry about it for now).  Once I'm in this search mode, typing `-e` as a search string and hitting "Enter" takes me to the first occurrence of said search string, and hitting `n` (for `next`) shows me the subsequent occurrences until I find the flag I'm looking for.  Eventually, that takes me to this section:

<p style="text-align: center">
  <img src="/assets/images/set-e.png" width="75%" alt="search for `-e`">
</p>

Just based on my personal instinct, the important text seems to be "If a command has a non-zero exit status, execute the ZERR trap, if set, and exit."  We'll dive more deeply into exit statuses and their meaning a bit later, but if you want answers now, check out [this link](https://archive.ph/nCzoq) from The Linux Documentation Project.  For now don't worry about "ZERR traps", although if you're curious, you can find more info on traps [here](https://archive.ph/50n41).

The text after this first sentence might also be helpful to my understanding, but it seems to require some knowledge that I don't yet possess, so I make the decision to skip it.  I might be wrong, though; if I get hit a dead-end, maybe I'll return to it.

Back to the first sentence, I interpret it to mean that, if you add `set -e` to your bash script and an error occurs, the program exits immediately, as opposed to continuing on with the execution.  OK, but... isn't that what happens anyway?  That's certainly what I see when I write a Ruby script and an error occurs.  Is the helpfile implying that a program would just continue executing if you *leave out* `set -e` and an error occurs?

Let's try an experiment to figure out whether that's the case.

### Experiment- will `set -e` cause a script to stop when an error is raised?

I make 2 bash scripts, one called `foo` and one called `bar`:

`foo` looks like so:

```
#!/usr/bin/env bash

set -e

./bar

echo "foo ran successfully"
```

It does the following:

 - declares the script as a `bash` script
 - calls `set -e` in the theory that this will cause any error to prevent the script from continuing
 - runs the `./bar` script, and
 - prints a summary line

In theory, if an error occurs when running `./bar`, our execution should stop and we shouldn't see "foo ran successfully" as output.

Meanwhile, `bar` looks like so:

```
#!/usr/bin/env bash

echo "Inside bar; about to crash..."

exit 1
```

It does the following:

 - declares the script as a `bash` script (just like in foo)
 - prints a logline to STDOUT, and
 - triggers a non-zero exit code (i.e. an error)

I had prior knowledge of `exit 1`, `exit 0`, etc., which is how I knew to leverage them to produce the desired result here.  If this is the first time you're encountering the concept of exit codes, we'll talk more about them eventually, but for now [here](https://web.archive.org/web/20230202185938/https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html) are the GNU docs on the subject.

I run `chmod +x` on both of these scripts, to make sure they're executable.  Then I run `./foo` in my terminal:

```
$ ./foo

Inside bar; about to crash...
```

OK, so we did **not** see the summary line from `foo` printed to the screen.  To me, this indicates that the execution inside `foo` halted once the `bar` script ran into the non-zero exit code.

Now I comment out `set -e` from `foo`:

<p style="text-align: center">
  <img src="/assets/images/commented-set-e.png" width="50%" alt="a commented-out `set -e` command">
</p>

Now when I re-run `./foo`, I see the following:

```
$ ./foo

Inside bar; about to crash...
foo ran successfully
```

This time, I **do** see the summary logline from `foo`.  This tells me that the script's execution continues, even though we're still getting the same non-zero exit code from the `bar` script.

Based on this experiment, I think we can conclude that `set -e` does, in fact, prevent execution from continuing when the script encounters an error.

### Aside- why isn't `set -e` the default?

But my earlier question remains- why must a developer explicitly include `set -e` in their bash script?  Why is this not the default?  This question feels like it has a subjective answer, meaning that I doubt the answer will be found in the `man` or `help` pages, so I decide to use StackOverflow.

There, I find [these](https://stackoverflow.com/questions/13468481/when-to-use-set-e) [two](https://serverfault.com/questions/143445/what-does-set-e-do-and-why-might-it-be-considered-dangerous) posted questions.  From reading the answers, I gather that there are valid reasons for not using `set -e`, including the ability to catch and handle different errors in different ways:

<p style="text-align: center">
  <img src="/assets/images/set-e-default.png" width="75%" alt="why is `set -e` not the default?">
</p>

Therefore, the reason `set -e` is not the default is *probably* because the UNIX authors wanted to give developers more fine-grained control over whether and how to handle different kinds of exceptions.  `set -e` lets you halt your program immediately whenever any kind of error is triggered, so you don't have to explicitly catch each kind of error separately.  Some people like to use it and some people don't; it appears to be a matter of preference.

Moving on to line 3 of the code.

## Tests and conditions

```
[ -n "$RBENV_DEBUG" ] && set -x
```

What do those brackets mean?  [This answer](https://stackoverflow.com/a/2188369/2143275) from StackOverflow says:

<p style="text-align: center">
  <img src="/assets/images/what-are-brackets.png" width="75%" alt="What are brackets in bash?">
</p>

OK, so `[` and `test` are synonyms as far as `bash` is concerned.  I run `man test` and see the following:

<p style="text-align: center">
  <img src="/assets/images/man-test.png" width="75%" alt="`man` entry for the `test` command">
</p>

Here we have a formal definition of `[` (aka `test`).  It's a "condition evaluation utility", which I interpret to mean that it's similar to an if-clause in Ruby.  Let's test whether that's true with an experiment:

### Experiment- `[` vs `test`

I create a file named `./foo`:

```
 if [ 5 == 5 ]; then
   echo "True"
 else
   echo "False"
 fi
```

I run `chmod +x foo` so I can execute the script, then `./foo`:
```
$ ./foo

True
```

I then change the condition to `5 == 6` to make sure the `else` clause also works:

```
#!/usr/bin/env bash

 if [ 5 == 6 ]; then
   echo "True"
 else
   echo "False"
 fi
```

When I run it, I see:

```
$ ./foo

False
```

I then update the script to use the `test` command instead of the square brackets, and repeat the experiment:

```
 if test 5 == 5; then
   echo "True"
 else
   echo "False"
 fi
```

Same results:

```
$ ./foo

True
```

Lastly, testing the `else` clause...

```
#!/usr/bin/env bash

 if test 5 == 6; then
   echo "True"
 else
   echo "False"
 fi
```

...results in:

```
$ ./foo

False
```

At least in this case, `test` and `[ ... ]` appear to produce the same results.

Now what about that -n flag?

## Passing `-n` to `[`

If we’re looking for docs on a flag that we’re supposed to pass to a certain command, we can usually find those docs inside the docs for the command itself. In this case, I search for `-n` in the `man` page for `test`:

<p style="text-align: center">
  <img src="/assets/images/man-test-n.png" width="70%" alt="Documentation for the `test` command's `-n` flag">
</p>

It looks like `[ -n "$RBENV_DEBUG" ]` returns a zero exit code (or in the parlance of a true/false check, it returns `true`) if the length of the string that it receives is greater than zero (i.e. if the string is *not* empty).  In this case, the string it receives is the value of the `RBENV_DEBUG` environment variable.

Let's see if `-n` behaves the way we expect.

### Experiment- the `-n` flag

First I run the following directly in my terminal tab:

```
$ export FOO='foo'

$ [ -n "$FOO" ] && echo "Hi"

"Hi"

$ [ -n "$BAR" ] && echo "Hi"

$ [ -n "" ] && echo "Hi"

```

This all works as expected.  Then, out of curiosity, I removed the double-quotes from `$BAR`:

```
$ [ -n $BAR ] && echo "Hi"
Hi
```

This was unexpected.  Since `$BAR` hadn't been set, I expected nothing to be printed to the screen.  I've read before that leaving the double-quotes off can cause unexpected behavior, depending on what the variable value is set to.  But if it's not set to anything, I would expect its length to be zero, and therefore the statement to return false.

Lastly, I removed `$BAR` entirely:

```
$ [ -n ] && echo "Hi"
Hi
```

Since I don't pass any value at all to the flag, I would expect the length of the non-existent "string" to be zero.

Why are the last two cases not returning the results I expect?

In this case, [this StackOverflow post](https://archive.ph/x5AYq) comes through with an answer:

> `[ -n ]` does not use the `-n` test.
>
> The `-n` in `[ -n ]` is not a test at all. When there is only one argument between `[` and `]`, that argument is a string that is tested to see if it is empty. Even when that string has a leading `-`, it is still interpreted as an operand, not a test. Since the string `-n` is not empty (it contains two characters, `-` and `n`, not zero characters) `[ -n ]` evaluates to true.

...and [here](https://unix.stackexchange.com/a/141025/142469):

> You need to quote your variables. Without quotes you are writing `test -n` instead of `test -n <expression>`. The `test` command has no idea that you provided a variable that expanded to nothing.

OK great.  So when I don't use double-quotes, the script thinks I'm just running `[ -n ]`, which the interpreter interprets as an operand of length 2, which is why it returns true.  This is true whether I'm running `[ -n ]` or `[ -n $BAR ]`.

-----------

Another question about the bracket syntax: what would happen if I used single-quotes instead of double-quotes?  Does that matter?  Time for another simple experiment.

### Experiment- single- vs. double-quotes

Since I've already defined my FOO variable in my terminal tab, I type the following in the same tab:

```
$ echo "$FOO"
```

Which results in:

```
foo
```

Next I use single-quotes:

```
$ echo '$FOO'
```

When I run it, I get the following:

```
$FOO
```

OK, so when using single-quotes instead of double-quotes, the shell doesn't expand the variable into its underlying value.  It just treats the variable name as a string literal, and in this case we echo that string to the terminal.

---------------

So if the `[ -n "$RBENV_DEBUG" ]` condition returns true, the `&&` syntax ensures that we then execute the 2nd half of this line of code: `set -x`.  If that condition returns false, we exit early and don't evaluate `set -x`.

We know about `set` already, but what does the `-x` flag do?

To find the answer, remember that we have to use `man zshoptions` to look up `set` flags:

<p style="text-align: center">
  <img src="/assets/images/man-zshoptions.png" width="75%" alt="`man` entry for the `zshoptions` command">
</p>

Using the `/` command from within `man zshoptions`, we type `-x` and keep hitting the `n` key until we see the following:

<p style="text-align: center">
  <img src="/assets/images/man-zshoptions-2.png" width="75%" alt="`man` entry for the `zshoptions` command">
</p>

There were a few other "hits" while searching for `-x` in `man zshoptions`, but they were either for the wrong case (i.e. the uppercase `-X` instead of the lowercase `-x`, which is a different flag), or else were in the body of the description for another command (ex.- the description for `GLOBAL_EXPORT <Z>` contains a reference to `-x`, but does not tell us what `-x` does).

The `man` entry tells us that the `-x` flag causes `bash` to "(p)rint commands and their arguments as they are executed".  That kind of sounds to me like what "debug mode" or "verbose mode" does in many command line programs.  Which would make sense given the condition for the `test` command.

Let's see if that's what happens.

-------------

### Experiment- the `set -x` command

I write a new script, run `chmod +x` on it, and add the following code:

<p style="text-align: center">
  <img src="/assets/images/exp-set-x.png" width="30%" alt="Experiment script- `set -x`">
</p>

Side note- I found out from [this link](https://stackoverflow.com/questions/6348902/how-can-i-add-numbers-in-a-bash-script) that you add two integers in `bash` with the `$((...))` syntax.

As you can see, this script includes `set -x` at the top.  When I run this script, I see the following:

<p style="text-align: center">
  <img src="/assets/images/set-x-results.png" width="50%" alt="Results of a script with `set -x` included">
</p>

The lines with `+` in front of them appear to be the lines which are printed out *as a result of `set -x`*, while the lines without `+` are lines that would have printed out anyway (i.e. as a result of the `echo` commands I included in the script).

Now, when I comment out `set -x` and re-run the script, I see:

<p style="text-align: center">
  <img src="/assets/images/set-x-results-2.png" width="50%" alt="Results of the same script without `set -x`">
</p>

Now we don't see the `+` lines.

From this, I think we can conclude that `set -x` prints each line of code that is run, just as our docs described.

-----------

So to summarize, `[ -n "$RBENV_DEBUG" ] && set -x` tells us that we will print each command as it is executed, but **only if** we set the `$RBENV_DEBUG` environment variable to equal  any non-empty string value.

### Aside- is it dangerous to rely on builtin commands?

Relatedly, while researching the `set` command, it dawned on me that if `man set` pulls up the "General Commands Manual", that must mean it's a builtin command (i.e. its implemented by a specific shell).  But RBENV is a widely-popular Ruby version manager, meaning it must be running on machines that use `bash`, but also machines that use `zsh` and other shells too.

Our file has a `bash` shebang, meaning `set` will always be evaluated using `bash`.  But if we didn't have that shebang, would there be any danger that the `set` command (and therefore RBENV) will behave differently in different shells?  More broadly, is it dangerous for a script to rely on built-ins, since they could be implemented differently in different shells?

I'm getting close to reaching my mental bandwidth limit for the day, so I decide to [post my question on StackOverflow](https://stackoverflow.com/questions/73447693/rbenv-is-it-risky-to-rely-on-builtin-shell-commands-such-as-set-since-builti).  A side benefit of this is that, in the past, just the act of writing out my question on StackOverflow has helped unblock me and helped me answer my own question, even when I don't end up posting it.

The next day, I see someone commented on my question:

```
As long as you stick to features from POSIX sh, you're usually pretty safe.
```

Googling for the phrase "POSIX docs", I find [the POSIX docs page](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_25) containing the `set` command, and verified that while it is considered a "special built-in", POSIX does have an opinion on its implementation:

```
If no options or arguments are specified, `set` shall write the names and values of all shell variables in the collation sequence of the current locale.
```

The use of the word "shall" seems to indicate that a shell is required to implement its version of `set` in the manner prescribed by POSIX if it wants to be considered POSIX-compliant.  This, I think, is enough to satisfy my question.

Note that I subsequently found [this blog article](https://archive.ph/JGREI), which seems to confirm my assumption that POSIX is the standard by which we can feel safe in using `set` in the rbenv shim.

-------------

<!-- ### Aside- asking questions on StackOverflow

When I'm writing a question on StackOverflow, I try to make my chain of thought as clear as possible.  Whenever I make an assertion, I explain why and how I came to that conclusion.  For example, if I make a statement because I read it on another StackOverflow post, I'll link to that post (or even better, I'll link to the specific answer on that post).  Doing this helps people who are trying to answer my question to see how I reached my conclusion.  If they aren't able to do this, it's harder for them to correct me effectively if my assertion is mistaken.

I try to phrase my question as usefully as possible, adhering to the StackOverflow community guidelines on [how to ask a good question](https://archive.ph/EHVnj).  The people who answer questions are taking valuable time out of their day to help less-knowledgeable folks like me, and I want to respect their time.

Sticking to the above guidelines will usually result in a well-written question.  However, I am only human and, despite my best efforts, I will sometimes make mistakes.  I hope that my good-faith effort to ask an effective question will be clear to others, but sometimes I still get downvoted or called-out by folks who are in a less-than-sympathetic mood for whatever reason.  I'd be lying if I said I didn't care at all when that happens- upvotes feel good, after all.  But at the end of the day, if I've done everything I can to craft my question well, I'm willing to lose a few internet points if it means I'll gain a little knowledge. -->

Moving on to the next line of code:

```
program="${0##*/}"
```

## Parameter Expansion

Judging by the variable name, it looks like we're trying to store the name of the program.  Let's see whether we're right with an experiment.

### Experiment- are we storing the string we think we're storing?

I edit the shim file (`~/.rbenv/shims/bundle`) to echo the value of `program` after the above line of code:

```
...
program="${0##*/}"
echo "program name: $program"
...
```

Then I run the following:

<p style="text-align: center">
  <img src="/assets/images/echo-program.png" width="50%" alt="echo the contents of the `program` variable">
</p>

Don't worry about `Could not locate Gemfile`- that's what happens when you try to run the `bundle` command in a directory without a file named `Gemfile`.  If I were to create an empty file named `Gemfile` and re-run the command, that error would go away and be replaced by a success message.

The important thing here is that the `bundle` command printed out `program name: bundle`.  Just to be safe, I do the same experiment with the shim for the `ruby` command (i.e. `~/.rbenv/shims/ruby`):

```
program="${0##*/}"
echo "program name: $program"
```

Then I run:

<p style="text-align: center">
  <img src="/assets/images/echo-program-2.png" width="50%" alt="echo the contents of the `program` variable">
</p>

Same thing- it printed the name of the first command I entered into the terminal, followed by the expected output of the `ruby -e "puts 5+5"` command.  By this point, I am confident that `${0##*/}` evaluates to "bundle" in my case.

Before I forget, I delete my `echo` commands from both the `bundle` and `ruby` shims.

But what is this weird syntax which evaluates to the name of the program?  After Googling that exact string ("${0##*/}"), I find [this StackOverflow link](https://archive.ph/1wCki), which says:

<p style="text-align: center">
  <img src="/assets/images/param-expansion-example-1.png" width="50%" alt="parameter expansion- first example">
</p>

The author claims that `$0` will evaluate to the path of the file that we're executing.  Let's test that out.

### Experiment- messing around with parameter expansion

I create a directory named "foo".  Inside of that a subdirectory also named "foo", and inside of that I create a file named "bar".  Inside of "bar" I type the following:

```
#!/usr/bin/env bash

echo "$0"
```

I then `chmod +x` it, so that it will execute:

```
$ chmod +x ./foo/foo/bar
```

And when I run it:

```
$ ./foo/foo/bar

./foo/foo/bar
```

The output was `./foo/foo/bar`, meaning we've verified that we can reproduce the `$0` behavior described in the StackOverflow post.

Based on the answer, I wondered whether wrapping `$0` in curly braces would change its output.  I tried this too:

```
#!/usr/bin/env bash

echo "${0}"
```

When I executed this updated version of `./foo/foo/bar`, it displayed the same output as before.  So `"$0"` and `"${0}"` seem to be functionally equivalent.

Now to test the 2nd part of the answer, about removing prefixes.  I'll first try the same syntax as in the StackOverflow answer (i.e. `##*/`):

```
#!/usr/bin/env bash

echo "${0##*/}"
```
When I run it:

```
$ ./foo/foo/bar

bar
```

So without the `##*/` syntax, we get `./foo/foo/bar` as our output.  With this new syntax, we get just `bar` as the output.  Therefore, adding `##*/` inside the curly braces had the effect of removing the leading `./foo/foo/` from `./foo/foo/bar`.

Out of curiosity, what happens when I remove one of the two "#" symbols?

```
#!/usr/bin/env bash

echo "${0#*/}"
```

Running it returns:

```
$ ./foo/foo/bar

foo/foo/bar
```

So instead of either `./foo/foo/bar` or `bar` as the output, now we get `foo/foo/bar`.

This is expected.  The StackOverflow answer mentions that including only one `#` will cause the parameter expansion to stop after matching the first case of its search pattern.  In this case, our search pattern is the `*/` character, meaning the first `/` character plus anything before it.  So one `#` will cause `./` to be removed, while two `##` will cause `./foo/foo/` to be removed.

Now, instead of trying to remove forward slashes, what if I try to remove "foo"?

```
#!/usr/bin/env bash

echo "${0#*/foo}"
```

And executing it returns:

```
$ ./foo/foo/bar

/foo/bar
```

Great, it removed `./foo` as expected.  And adding back the 2nd `#`?

```
#!/usr/bin/env bash

echo "${0##*/foo}"
```

Running it returns:

```
$ ./foo/foo/bar

/bar
```

This time it removed `./foo/foo`, or both instances of the `*/foo` pattern.  I think we can call this experiment a success.

Lastly, going back to the concept that the StackOverflow answer mentioned, i.e. "parameter expansion".  I Google around a bit and find [this link](https://web.archive.org/web/20220816200045/https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html), which looks like good documentation for me to bookmark and refer back to later, if I need to.

I feel like my understanding of the topic is good enough for now.  Next line of code.

## Conditional statements

```
if [ "$program" = "ruby" ]; then
...
fi
```

We already know what the bracket syntax does.  We also know we need double-quotes to expand our `program` variable safely.  And `if ... then` is one of the few bash commands which is likely to be readable to a layperson.  `fi` is just the way to close an `if` statement in `bash`.

So the purpose of this `if` check is to ensure the subsequent code only gets executed if the user typed `ruby` into the terminal as the program name.  Otherwise, nothing inside the `if` block gets executed.  Later, we'll examine that subsequent code and what it actually does.

The one thing that trips me up is the single equals sign.  In Ruby, we use single equals for variable assignment and double-equals for a comparison.  And in fact, we literally *just did that* here in `bash`-land, when we assigned to the `program` local variable using a single-equals sign.  But in bash, it looks like you can get away with single equals for a comparison operation, as long as the comparison is wrapped in square brackets?

To see whether this is true, we'll do yet another experiment.

### Experiment- double- vs. single-equals comparison

I run the following experiment, in a new script file:

```
#!/usr/bin/env bash

program='ruby'
[ "$program" == "ruby" ] && echo "True"
```

When I `chmod` the file and run it, `True` prints out.  OK, using double-equals sign for a comparison operation does, in fact, work in bash.  I then remove one of the equals signs and run it again, and the same thing happens.  So it seems like, in bash, the double- and single-equals syntaxes are equivalent.

To confirm this further, I Google "bash double vs single equals" and I find [this StackOverflow post](https://stackoverflow.com/questions/12948456/is-there-any-difference-between-and-operators-in-bash-or-sh):

<p style="text-align: center">
  <img src="/assets/images/equals-sign.png" width="70%" alt="the difference between = and == in bash">
</p>

OK, so even though we're guaranteed to be using the `bash` shell by the time we execute this code (because of the shebang), we don't know *which version of `bash`* we're using.  It could be an older version, perhaps even one which doesn't support double-equals for a comparison operation.

Interestingly, I also try running the following directly in my terminal, without creating a whole new file (remember my terminal is zsh):

```
[ "$program" == "ruby" ] && echo "True"
zsh: = not found
```

So does that mean we can’t use double-equals in zsh?

To answer this, I Google around a bit and find [this link](https://archive.ph/2iSkK) for a StackOverflow question titled:

<p style="text-align: center">
  <img src="/assets/images/title-of-so-question.png" width="70%" alt="title of so question">
</p>

Apparently in `zsh`,...

```
a == is a logical operator only inside [[ ... ]] constructs.
```

I’m pretty sure that "==" is an example of a "logical operator", so the above implies that I need to use double-brackets in my command.

So what’s the difference between single- and double-`[`?

## Double- vs. single-`[`

[This StackOverflow page](https://web.archive.org/web/20220602085208/https://serverfault.com/questions/52034/what-is-the-difference-between-double-and-single-square-brackets-in-bash) provides some help:

<p style="text-align: center">
  <img src="/assets/images/brackets.png" width="70%" alt="bracket syntax in bash">
</p>

OK, so `[` is more POSIX-compliant than `[[`, therefore it’s more portable across a wider array of machines.  `[[` is more modern and comes with some helpful updates, so it can sometimes be easier to use.  But if you’re writing a script that will be used by many people and you can’t predict which shell they’ll run it on (or which version of a shell), you’re probably safer using `[`.

Tangent: Further down in that StackOverflow link, I subsequently discovered that I *can* use single-brackets, but I have to wrap my double-equals sign in quotes, like this:

```
[ "$program" '==' "ruby" ] && echo "True"
True

```

Double-quotes worked as well, for what it's worth.


## IFS and delimiters

From prior knowledge, I happen to know that UNIX uses an environment variable named "IFS", which stands for "internal field separator".  That's the "IFS variable" which the above StackOverflow answer is referring to, in the comment at the bottom.  Here's [a link](https://web.archive.org/web/20220715010436/https://www.baeldung.com/linux/ifs-shell-variable) with more info.  My understanding is that an `IFS` is basically a "delimiter", i.e. a character or characters that we use to separate fields in a concatenated string.  The link contains an experiment, which I've replicated below so we can see what they're useful for.

### Experiment- IFS and delimiters

I’ve modified their script to add a shebang to make sure it runs on my machine:

```
#!/usr/bin/env bash

string="foo bar baz"

for i in $string
do
  echo "'$i' is the substring"
done
```
When I run the script, I see:

```
$ ./foo
'foo' is the substring
'bar' is the substring
'baz' is the substring
```

I then change the string declaration to:

```
string="foo:bar:baz"
```

When I re-run the script, I get:
```
$ ./foo
'foo:bar:baz' is the substring
```

Lastly, I re-define the `IFS` env var like so:

```
IFS=":"
```

When I re-run the script, I get:
```
$ ./foo
'foo' is the substring
'bar' is the substring
'baz' is the substring
```

This illustrates that the empty-space character " " was the default internal field separator on my machine.  Replacing ` ` with `:` in *both* the string and the `IFS` variable resulted in the same output, but making that same change in only the string *or* the variable would result in a single line of output, rather than 3 separate lines.

This experiment also shows that iterating over a string is similar to iterating over an array, where the items in the array are equivalent to the items in the string separated by the value of `$IFS`.  So if, like my machine, yours uses the " " character, then a string like "foo bar baz" (with 3 words and two spaces) will be separated into 3 separate strings ("foo", "bar", and "baz") for the purposes of iteration.

Moving onto the next line of code.

## for-loops in bash

```
  for arg; do

  ...

  done
```
This one’s a bit weird: up to this point, we haven't seen the `arg` variable explicitly defined by the code.  If we haven't seen this variable defined yet, that implies that it’s defined or built-in by the language.  As usual, Googling turns up [a StackOverflow post](https://archive.ph/p4Cjp):

<p style="text-align: center">
  <img src="/assets/images/arg-for-loop.png" width="70%" alt="What is `arg` in a bash `for` loop?">
</p>

Scrolling down in the answer a bit, we see:

<p style="text-align: center">
  <img src="/assets/images/arg-for-loop-2.png" width="70%" alt="Omitting `in` in a bash `for` loop?">
</p>

The above statement implies that `$@` expands to the list of arguments provided to the script.  Let’s see if that’s true with another experiment.

### Experiment- what does `$@` evaluate to?

I write a new script (again named simply "foo"):

```
#!/usr/bin/env bash

echo "$@"
```

Running the script with some random arguments, we get:

```
$ ./foo bar baz buzz

bar baz buzz
```

Changing the script a bit:

```
#!/usr/bin/env bash

for arg in "$@";
do
  echo "$arg"
done
```

Running this, we get:

```
$ ./foo bar baz buzz
bar
baz
buzz
```
And finally, testing whether we can eliminate `in "$@"`:

```
#!/usr/bin/env bash

for arg;
do
  echo "$arg"
done
```
Running this results in:

```
$ ./foo bar baz buzz
bar
baz
buzz
```

Awesome!  So we learned:

 - `$@` stands for the arguments that you pass to the script
 - If you write a `for` loop but leave off the `in ___` part, bash defaults to using `$@`

Moving on to the next line:

## Case statements

```
case "$arg" in
...
esac
```

I've seen case statements before (Ruby has them, as well), but I still feel like familiarizing myself with any bash-specific idiosyncracies.

I find [this link](https://web.archive.org/web/20220820011836/https://linuxize.com/post/bash-case-statement/), which explains bash’s case statement syntax.  I would have preferred a more official link, but as of 25 Aug 2022 the official docs don’t show up on page 1 of the search results.  At any rate, here are the highlights:


1. Each `case` statement starts with the `case` keyword, followed by the case expression and the `in` keyword. The statement ends with the `esac` keyword.

1. You can use multiple patterns separated by the `|` operator. The `)` operator terminates a pattern list.

1. A pattern can have [special characters](https://web.archive.org/web/20220820011901/https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html).

1. A pattern and its associated commands are known as a clause.

1. Each clause must be terminated with `;;`.

1. The commands corresponding to the first pattern that matches the expression are executed.

1. It is a common practice to use the wildcard asterisk symbol (`*`) as a final pattern to define the default case. This pattern will always match.

1. If no pattern is matched, the return status is zero. Otherwise, the return status is the [exit status](https://web.archive.org/web/20220806222213/https://linuxize.com/post/bash-exit/) of the executed commands.

None of this is terribly surprising, since these rules all appear to match how case statements work in Ruby and other languages I've worked with.  If this is the first time you've encountered case statements before, [here](https://archive.ph/XL1RH) are the Mozilla docs for case statements in Javascript, and [here](https://archive.ph/A9qqn) are the docs for the Ruby version of case statements.  They're both pretty straight-forward and lacking in technical jargon.

The above bullet points also explain the syntax of the subsequent line, which is a condition that the case statement will match against:

```
    -e* | -- ) break ;;
    ...
```

We see two patterns (`-e` and `--`), separated by the `|` character, then terminated by the `)` character, as mentioned in bullet point 2 above.  If the current arg in the iteration matches either pattern, we exit the `for` loop (i.e. we `break`).

Because of point #7 above, I suspect that any text starting with `-e` would fit the `-e*` pattern.  To prove it, I perform an experiment.

### Experiment- the `-e*` flag in a case statement

I write the following script:

```
#!/usr/bin/env bash

for arg; do
  case "$arg" in
    -e* ) echo "Pattern matched; exiting..."
    break ;;
    * )
      echo "arg is: $arg" ;;
  esac
done

echo "Outside the for loop"
```

This is a simplified version of the original case statement.  It iterates over the args, and if an arg matches `-e*`, we echo a test string ("Boom!") and break out of the loop.  Otherwise, we just echo the arg itself and keep iterating.  When we’re done with all the args in the loop, we echo "Outside the for loop" to indicate that the script is finished.

I then run the following:

```
$ ./foo bar -ebaz buzz
arg is: bar
Pattern matched; exiting...
Outside the for loop
```

So we printed our first arg, and then "Pattern matched; exiting...", then we did *not* print the third arg.  This is because "-ebaz" starts with "-e", which matched the `break` condition of `-e*`.  Lastly, we printed "Outside the for loop" to prove that `break`ing doesn’t result in an exit of the entire script.  Based on this result, I think we can safely say that we were correct, and the `-e*` flag returns true if a given string starts with `-e`, regardless of what follows after.

To figure out what the `-e` flag actually does, I just ran `ruby –help` and searched for the `-e` entry.  This flag lets you execute Ruby code directly in your terminal, without having to pass a filename to the Ruby interpreter:

<p style="text-align: center">
  <img src="/assets/images/ruby-help-e.png" width="70%" alt="`ruby --help` output`">
</p>

For example:

```
$ ruby -e "puts 'Hello'"

Hello
```

So passing Ruby code directly to the `ruby` interpreter in your terminal (via the `-e` flag) is one of the two scenarios which will cause `rbenv` to assume that any **subsequent** args are meant to be positional args, not flags to the `ruby` command itself.

Regarding the 2nd pattern (`--`), I’ve seen it used in terminal commands before but I doubt I could explain its purpose.  StackOverflow [saves the day again](https://web.archive.org/web/20220623104640/https://unix.stackexchange.com/questions/11376/what-does-double-dash-mean):

<p style="text-align: center">
  <img src="/assets/images/double-dash.png" width="70%" alt="What is a double-dash?">
</p>

I think this means that everything before `--` is meant to be a flag, and everything after that is an argument to the script itself.

Hmmm OK, but you still need to be able to process the subsequent arguments in the script, right?  In our case, if the text matches the `--` pattern, does that mean the script breaks out of the list of args, meaning we won’t process anything after `--`?

Not quite.  We'll see shortly that the last line of the shim file makes use of `"$@"` again, specifically to pass those args to `$program`.  The value of `$@` is not modified at all by anything in the `for` loop, so all the args which get passed to the shim file are *also* passed in their original form to `$program`.  By `break`ing here, the only thing we're doing here is preventing those positional arguments from affecting the value of `RBENV_DIR`, which (as we'll see shortly) is the real purpose of the `for`-loop.

## More pattern-matching with case statements

Next line of code:

```
    */* )
      ...
      ;;

```

Judging by the `)` terminator character and the `;;` a few lines down, this looks like another pattern that the case statement will match against.  The only thing that throws me off is the difference between the above pattern (`*/* )`) and the one in my experiment script (`* )`), which I borrowed from the link on case statements.  It looks like it’s searching for a forward-slash, with zero or more characters before and/or after it.  In other words, most likely a file path.  Let’s check that with an experiment.

### Experiment: how to check for a filepath in a case statement

I make a `bash` script which looks like so

```
#!/usr/bin/env bash

for arg; do
  case "$arg" in
    */* )
      echo "match: $arg";
    ;;
    * )
      echo "not a match: $arg";
    ;;
  esac
done
```

I then run the following in my terminal:

```
$ ./foo 1 2 3 a/b /b a/ / ''
not a match: 1
not a match: 2
not a match: 3
match: a/b
match: /b
match: a/
match: /
not a match:
```

So yes, it appears to be looking for strings which match the `/` symbol with zero or more characters of text on either side.

But just because it *looks* like a valid filepath, doesn't mean it *is* one.  So how do we know it’s a file?

The next line of code tells us:

## Detecting whether a string is a filepath

```
if [ -f "$arg" ]; then
...
fi
```

Running `man test` and searching for the `-f` string reveals the following:

<p style="text-align: center">
  <img src="/assets/images/man-test-f.png" width="70%" alt="What is the `-f` flag when passed inside brackets?">
</p>

> True if file exists and is a regular file.

So our case statement matches if the arg *could be* a filepath, and we further check this by using `[ -f "$arg" ]` to verify that it *actually is* a filepath.

FWIW, I'm guessing they say "regular file" here in order to distinguish from other types of files which are mentioned in other flag descriptions, such as "block special file" for the `-b` flag, and "character special file" for the `-c` flag.  In case you're wondering what these special files are all about, I found [this StackOverflow post](https://archive.ph/GVuaN) which appears to contain the answer.  I didn't spend too much time on this, however, because it doesn't look especially relevant to our goal here.

To test whether the `-f` flag behaves the way I think it does, I update my `foo` script to look like the following:

```
#!/usr/bin/env bash

for arg; do
  case "$arg" in
    */* )
      echo "match: $arg";
      if [ -f "$arg" ]; then
        echo "is definitely a filepath";
      else
        echo "turns out, is not a filepath";
      fi
    ;;
    * )
      echo "not a match: $arg";
    ;;
  esac
done
```

Then I run:

```
$ echo "bar" > bar
```

I run this command so that I have a file in my directory called `./bar`.

Lastly, I run the following:

```
$ ./foo 1 2 3 a/b /b a/ / '' ./bar foo

not a match: 1
not a match: 2
not a match: 3
match: a/b
turns out, is not a filepath
match: /b
turns out, is not a filepath
match: a/
turns out, is not a filepath
match: /
turns out, is not a filepath
not a match:
match: ./bar
is definitely a filepath
not a match: foo
```

As expected, the arguments which are known to *not* match a file in my current directory (i.e. `a/b`, `/b`, `a/`, and `/`) result in the output `turns out, is not a filepath`.  My `./bar` argument, which is known to match a file, results in the output `is definitely a filepath`.

But wait, the last argument (`foo`) *also* matches a filepath, i.e. the `./foo` script we're running!  It doesn't match because it doesn't have a `/` in its argument, but it *still is* a file.  Does that mean the RBENV shim is accidentally *skipping* some filepaths which it should be capturing?

Let's try an experiment which should tell us whether this is in fact happening with the shim for the `ruby` command.

### Experiment- are we skipping potentially valid filepaths?

I update the shim for my `ruby` command to look like the following.  Newly-added lines are indicated with comments in blue at the right of the screenshot:

<p style="text-align: center">
  <img src="/assets/images/new-ruby-shim.png" width="70%" alt="shim for `ruby` command with echo statements">
</p>

I then make a new file called `bar.rb`, which just contains the following:

```
puts 5+5
```

When I run `ruby bar.rb`, I see the following:

```
$ ruby bar.rb

arg: bar.rb
-----
10
```

However, when I run `ruby ./bar.rb`, I see the following:

```
$ ruby ./bar.rb

arg: ./bar.rb
arg matches */*: ./bar.rb
about to set RBENV_DIR for arg ./bar.rb
10
```

Judging by the fact that we see `about to set RBENV_DIR...` in the 2nd test case but not the first, we can say that adding `./` before `bar.rb` definitely causes additional code to be executed in our shim, above and beyond what gets executed when we pass only the filename **without** the relative directory path included.

Does this matter?

The answer to that is tied to what this case branch's purpose is.  We'll see what that is in the next section.

Before I move on, I make sure to delete the modifications I made to my `ruby` shim file.

Next 2 lines of code are:

```
export RBENV_DIR="${arg%/*}"
break
```

Here we see that the purpose of our case statement is to set the `RBENV_DIR` environment variable.

## What does the `RBENV_DIR` env var do?

Based on the name `RBENV_DIR`, I initially expect it to point to the directory that `rbenv` is installed in, not the directory that contains the ruby file to be executed.

To see if I'm right, I search for it in the `rbenv` codebase on my local machine (which I've downloaded from [the Github repo](https://github.com/rbenv/rbenv/tree/c4395e58201966d9f90c12bd6b7342e389e7a4cb)).

Note that I search using the `ag` command, which you can learn how to install [here](https://github.com/ggreer/the_silver_searcher).  Your computer will likely ship with the `grep` command, but `ag` is *much* faster.

When I run this search, I see multiple references to it in various code files:

<p style="text-align: center">
  <img src="/assets/images/ag-rbenv-dir.png" width="70%" alt="Searching the rbenv codebase for RBENV_DIR">
</p>

The reference that catches my eye is in the README.md file, since this will likely tell me in plain English what I want to know:

<p style="text-align: center">
  <img src="/assets/images/rbenv-env-vars.png" width="70%" alt="Environment variables in RBENV">
</p>

So the intention is for `RBENV_DIR` to control where `rbenv` looks for your `.ruby-version` file.  This makes sense to me; I happen to know from experience that the `.ruby-version` file is one way that RBENV uses to detect which Ruby version you want to use.  It’s quite common, when running a Ruby file that depends on a specific Ruby version, to include a `.ruby-version` file in the same directory as the executed file.  This file contains the hard-coded version number that you want to use when running your Ruby script, and is one method you can use to tell RBENV to pin your project to a specific Ruby version.

## `export` statements

The assignment statement `export FOO=’bar’` creates a variable named `FOO` and sets its value to `bar`, **but** it does something else as well.  We’ve already seen variables declared earlier, i.e. `program="${0##*/}"`.  What does the use of `export` buy us?

[It turns out](https://web.archive.org/web/20220713174024/https://www.baeldung.com/linux/bash-variables-export) there are two kinds of variables in a bash script: a shell variable and an environment variable.  When we created the `program` variable, that was an example of creating a **shell** variable.  Shell variables are only accessible from within the shell they’re created in.  Environment variables, on the other hand, are accessible from within child shells created by the parent shell.

The blog post link above gives two examples, one demonstrating access of an environment variable from a child shell, and the other of accessing a shell variable from a child shell.  We can do an experiment in our terminal to see for ourselves.

### Experiment- environment vs shell variables

We can type the following directly in our terminal:

```
$ export MYVAR1=1729
$ MYVAR2=46
$ echo $MYVAR1
1729
$ echo $MYVAR2
46
$ bash    # Open a new child shell
bash $ echo $MYVAR1
1729
bash $ echo $MYVAR2

```

We can see here that `MYVAR1` is visible from within our new child shell, but `MYVAR2` is not.  That's because the declaration of `MYVAR1` was prefaced with `export`, while the declaration of `MYVAR2` was not.

So our current line of code creates an environment variable called `RBENV_DIR`, which will be available in child shells.  This implies that we'll be creating a child shell soon.  What will that child shell do?  We'll need to wait and see.

In the meantime, what’s the value of the variable?  To answer that, we have to know what the following resolves to:

```
"${arg%/*}"
```

Let’s try an experiment.

### Experiment- more fun with parameter expansion

Although I'm not 100% sure whether parameter expansion  works similarly between `bash` and `zsh`, I feel OK about doing the following directly in my terminal (as opposed to inside a script with a `bash` shebang):

```
$ arg="/foo/bar/baz"
$ bar="${arg%/*}"
$ echo $bar

/foo/bar
```

So `"${arg%/*}"` takes the argument, and trims off the last `/` character and everything after it.  This aligns with something I found earlier, in [the GNU docs](https://web.archive.org/web/20220816200045/https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html):

<p style="text-align: center">
  <img src="/assets/images/gnu-docs-param-expansion.png" width="70%" alt="GNU docs for parameter expansion">
</p>

As a reminder, the line of code that we're examining now is:

```
export RBENV_DIR="${arg%/*}"
```

With the above reminder, we now know enough to piece together what this line of code is doing.  It:

 - creates a new environment variable named `RBENV_DIR` which will be available in any child shells
 - takes the directory of the (presumably) Ruby file that was passed to the `ruby` command, and
 - sets the new env var equal to the *directory containing that Ruby file*.

------------

Here's a reminder of the entire `if` block we just looked at:

```
if [ "$program" = "ruby" ]; then
  for arg; do
    case "$arg" in
    -e* | -- ) break ;;
    */* )
      if [ -f "$arg" ]; then
        export RBENV_DIR="${arg%/*}"
        break
      fi
      ;;
    esac
  done
fi
```

Summing up what all this does:

 - If the command you’re running is the `ruby` command:
 - RBENV will iterate over each of the arguments you pass to the executed program
 - If the arg is `--` or if it starts with `-e`, it will immediately stop checking the remaining args, and proceed to running the code outside the case statement (TBD what that is).
 - if the argument contains a `/` character, RBENV will check to see if that argument corresponds to a valid filepath.  If it does, it will grab the file’s parent directory and use that to (later on) check which Ruby version to use.

------------

The next line of code is pretty straight-forward:

```
export RBENV_ROOT="~/.rbenv"
```

## Setting `RBENV_ROOT`

This line of code just sets a 2nd environment variable named `RBENV_ROOT` to (in my case) the `.rbenv` hidden directory inside my home directory.  Referring back to the `README.md` file we just read, we see that this env var "Defines the directory under which Ruby versions and shims reside."  In other words, this env var does what I initially thought `RBENV_DIR` did.  Given this is an env var and not a shell var, we can assume that this variable might be used by a child process.

------------

Next line of code:

```
exec "/usr/local/bin/rbenv" exec "$program" "$@"
```

## Executing the original gem

What does the `exec` command at the start of the line do?  I first try `man exec` but I get the "General Commands Manual", indicating that this is a builtin command.  I then try `help exec` and see:

```
$ help exec
exec [ -cl ] [ -a argv0 ] [ command [ arg ... ] ]
       Replace the current shell with command rather than forking.   If
       command  is  a  shell  builtin  command or a shell function, the
       shell executes it, and exits when the command is complete.
```

OK, so we're *replacing the current shell* with the command that we're running, "rather than forking".  It then, depending on certain conditions, may exit after the command is complete.

What does all that mean?

I have a feeling that I'm not going to get a plain-English explanation from the docs, so I search Google for "what is exec in bash".  One of the first links I find is from [ComputerHope](https://archive.ph/axmcj), which in the past I've found to provide readable, beginner-friendly answers to my questions:

<p style="text-align: center">
  <img src="/assets/images/what-is-exec.png" width="70%" alt="What is the `exec` bash command?">
</p>

OK... that still creates more questions than it answers:

 - What's a process?
 - What's the difference between forking a process and replacing the current process with the new one (i.e. what `exec` does)?
 - Why use `exec` over forking, or vice-versa?

## What is a process?

I Google "what is a process in unix" and find a few answers.  The first one is from [TechTarget.com](https://archive.ph/1gKHE):

<p style="text-align: center">
  <img src="/assets/images/what-is-a-process.png" width="70%" alt="What is a process in UNIX?">
</p>

So from this definition, we learned that:

 - "A process is an instance of a program running on your computer."
 - One process (the "parent process") can create a new process (the "child process").
 - The child process shares resources with the parent process.  I'm not yet sure what resources they mean.
 - If the parent process dies, the child process also dies.

Another useful link comes from [TheUnixSchool.com](https://archive.ph/0qS4Y):

<p style="text-align: center">
  <img src="/assets/images/what-is-a-process-2.png" width="70%" alt="What is a process in UNIX?">
</p>

From this link, we additionally learned that:

 - A process has properties associated with it, such as a PID, a PPID, etc.
 - `ps` is a command we can use to see which processes are currently running.

OK, I guess this helps somewhat.  But what's the difference between `exec`ing and `fork`ing?

[This StackOverflow answer](https://stackoverflow.com/a/1653415/2143275) is the best I've found so far in answering this question:

<p style="text-align: center">
  <img src="/assets/images/fork-vs-exec.png" width="70%" alt="What's the difference between `fork` and `exec`?">
</p>

It appears that, if you know the parent process will be done after running the child process, then `exec` is the way to go because you can re-use the parent's process ID instead of creating a new one.  On the other hand, if the parent still has work to do after the child finishes executing, then `fork` is the way to go.

One use case they give for `fork`ing (rather than `exec`ing) is a web server that needs one process to spin off and handle a request that the server receives, while the parent thread continues to listen for new requests in a separate process.

## Experiment- messing around with `exec`

Directly in my terminal, I run:

```
$ exec "/usr/bin/env" ruby -e "puts 5"
5

[Process completed]
```

Since "the shell exits when the command is complete", the final output I see in my terminal tab is `[Process completed]`, and I can no longer run any commands in this tab.  I have to close this tab and open a new one to resume entering commands in the terminal.

Next, I open a new tab and update my executable `./foo` script to read as follows:

```
#!/usr/bin/env bash

echo "PID of foo: $$"

./bar
```

I then update `./bar` to read as follows:

```
#!/usr/bin/env bash

echo "PID of bar: $$"
```

In `./foo`, I'm just calling `./bar` directly, with no `exec` beforehand.  I theorize this will default to a `fork`, and that the PID printed by `./foo` will be different from that printed by `./bar`.  I run `./foo` in my terminal and see the following:

```
$ ./foo

PID of foo: 57955
PID of bar: 57956
```

In this case, I was right!  Now, I update `./foo` to preface `./bar` with a call to `exec`:

```
#!/usr/bin/env bash

echo "PID of foo: $$"

exec ./bar
```

When I run it, I get:

```
$ ./foo

PID of foo: 58695
PID of bar: 58695
```

Now the PIDs are the same!

-------------

So that’s what the shell builtin `exec` command does.  But the line of code we're looking at is:

```
exec "/usr/local/bin/rbenv" exec ...
```

This means we're running the builtin `exec` command, and *passing it* the `rbenv exec` command.  What does `rbenv exec` do?

I check whether `rbenv exec` accepts a `--help` command:

```
$ rbenv exec --help
Usage: rbenv exec <command> [arg1 arg2...]

Runs an executable by first preparing PATH so that the selected Ruby
version's `bin' directory is at the front.

For example, if the currently selected Ruby version is 1.9.3-p327:
  rbenv exec bundle install

is equivalent to:
  PATH="$RBENV_ROOT/versions/1.9.3-p327/bin:$PATH" bundle install
```

So `rbenv exec` ensures that, when UNIX is checking `PATH` for a directory containing the command we entered, the first directory it finds is the one containing the version of Ruby you have set as your current version.  And because the shim file is where `rbenv exec` is called, the only thing we need to do is call the shim file.  Since the shim file always has the same name as the program itself, we don't have to change what we do at the commnd line.  We just do what we would have done anyway, which is type the name of our desired program!

**This is the heart of how RBENV ensures a clean separation of Ruby versions**- it stores them in separate folders, uses shims to intercept calls to Ruby programs, looks for your program in in the folder for your currently-selected Ruby version, and then executes *that* installation of your program.

## But wait!

Why do we need the `ruby`-specific if block in *every* shim, regardless of whether it's a `ruby` shim or not?

To answer that, let's combine what we learned about the current case branch with what we learned about the `RBENV_DIR` environment variable.

### Aside- investigating the origins of the `if` block in the shim file

If you try to run a Ruby filepath from another directory outside of the directory you're in, RBENV will look for the `.ruby-version` file in *that* directory, which may have a `.ruby-version` file containing a different Ruby version from the version RBENV is currently using.  But if you only give the `ruby` command a certain filename with no parent directory / directories, then it looks for that filename in your current directory.

So my theory is that the purpose of this logic is to handle the case where you're running a Ruby file from a different directory, one with a (potentially) different Ruby version.

To see whether this is true, let's use git and Github to find the commit which introduced this change.

### Experiment- using git + Github to find where a change was introduced

I use `ag` to find the location in the `rbenv` codebase where the shim code lives.  I pick a line of code which I think will be uncommon, and therefore will produce the highest signal-to-noise ratio in our `ag` results:

<p style="text-align: center">
  <img src="/assets/images/ag-program-equals.png" width="70%" alt="searching or the shim code">
</p>

The shim code lives in a file named `libexec/rbenv-rehash`.  I copy this filepath and run `git blame` on it (docs on this command [here](https://archive.ph/iSiLS)):

<p style="text-align: center">
  <img src="/assets/images/git-blame-rbenv-rehash.png" width="70%" alt="output of the `git blame` command for the `libexec/rbenv-rehash` file">
</p>

This is a lot of info, but what we care about is the left-most column, which contains the unique identifier (called a SHA) of the commit which introduced each line of code.  In our case, we want line 64.  Luckily for us, the SHA (`283e67b5`) is the same for the entire `if` block, so we can be fairly confident that looking up that commit on Github will yield *something* useful, if we know how to read it right.

I open my web browser and go to Github, where I type the SHA value into the search bar on the top-left and select "In this repository":

<p style="text-align: center">
  <img src="/assets/images/searching-github-for-sha.png" width="70%" alt="output of the `git blame` command for the `libexec/rbenv-rehash` file">
</p>

Although Github says "we couldn't find any code...", we're not looking for this SHA in the *code repository*.  We're looking for it in the *git history*.  And on the left-hand side, we can see that Github did find one issue and one commit containing this SHA.  I right click on each section to open them in new tabs.

First the commit results:

<p style="text-align: center">
  <img src="/assets/images/git-commit-history-for-sha.png" width="70%" alt="Github's results for the commit history containing our SHA">
</p>

Reconstructing the commit message (which was cut off due to length), e can see at the top that the commit message for this commit was:

```
When the ruby shim is invoked with a script, set RBENV_DIR to the script's dirname
```

Looks like our hunch may have been a good one!  Let's also check [the issue link](https://github.com/rbenv/rbenv/pull/299):

<p style="text-align: center">
  <img src="/assets/images/rbenv-issue-page.png" width="50%" alt="The newer Github issue related to the PR which introduced this if-block.">
</p>


The description says `This branch adjusts the behavior of the ruby shim, when invoked with the path to a Ruby script as an argument, to set RBENV_DIR to the directory of the given script.  It should, in effect, remove the need for the ruby-local-exec shebang line.`  That sounds pretty close to what we hypothesized.  Based on this, I think we can safely say that we now know for sure that the `if` block was introduced as a more robust alternative to the code's previous strategy of setting the `RBENV_DIR` environment variable.

## Diving into the Github rabbit hole

But there's something here I still don't understand, specifically that 2nd sentence `It should, in effect, remove the need for the ruby-local-exec shebang line.`  It sounds like there was a previous attempt to solve the problem of setting `RBENV_DIR` which involved a special type of shebang, called `ruby-local-exec`.  What was wrong with that strategy?  Why was our adding of the `if`-block an improvement on that old strategy?

Luckily, in [the first PR we looked at](https://github.com/rbenv/rbenv/pull/299), there's [a link to another PR](https://github.com/rbenv/rbenv/pull/298), which contains the bulk of the discussion among the maintainers around this shebang:

<p style="text-align: center">
  <img src="/assets/images/rbenv-issue-page-2.png" width="50%" alt="The older Github issue where the discussion around a solution occurred.">
</p>

Oof, this is a long discussion; my screenshot doesn't even capture it all.

On the plus side, it looks like this PR captures more info on why `ruby-local-exec` was sub-optimal, but a lot of the discussion is over my head.  I decide to find the original commit which introduced the file, as well as any Github issue(s) that might be associated with it, in the hope that a lot of the knowledge which is assumed in the above discussion will be made more explicit in the PR.

In order to do this, I need the SHA of the commit which introduced the file.  If the file still existed within the code repo, this would be easy to find, since I could just run `git blame` on the file repeatedly, take the SHA from oldest line of code in the output, check out the SHA before that one, and repeat until I had reached the beginning of that file's git history.  Since the file no longer exists, however, I have to search Github for an older version of the repository which contains the file, check out that older version, and then run the above rinse-and-repeat steps locally.

The fastest way to get started doing this is to just type "ruby-local-exec" in Github's search field while inside the Github repository (i.e. while my browser is pointed to `https://github.com/rbenv/rbenv`).  When I do this, the "In this repository" option appears in a dropdown, and I click that.

<p style="text-align: center">
  <img src="/assets/images/rbenv-local-exec-search.png" width="50%" alt="Searching Github for the string 'rbenv-local-exec'." >
</p>

I'm taken to a search results page, which (among other things) indicates that Github found 6 commits with this string present.  I click on "Commits" to see which commits those were:

<p style="text-align: center">
  <img src="/assets/images/search-results-for-rbenv-local-exec.png" width="50%" alt="Github Search results for the string 'rbenv-local-exec'." >
</p>

From there, I see a list of git commits, along with their commit messages.  The commit labeled "Add experimental `ruby-local-exec`" looks promising, so I click on that:

<p style="text-align: center">
  <img src="/assets/images/search-results-for-rbenv-local-exec-2.png" width="50%" alt="Github Search results for the string 'rbenv-local-exec'." >
</p>

From there, I'm taken to a list of files, which (in the case of this PR) is just one file- the one I want (`bin/ruby-local-exec`):

<p style="text-align: center">
  <img src="/assets/images/rbenv-local-exec-commit.png" width="50%" alt="The original commit for the 'rbenv-local-exec' file." >
</p>

On the right-hand side of the screen, I see the following:

<p style="text-align: center">
  <img src="/assets/images/commit-SHA-for-rbenv-local-exec.png" width="50%" alt="Original commit SHA for the 'ruby-local-exec' file." >
</p>

Among other things, this tells us that the SHA for this commit starts with `1411fa5`.  In my terminal, I navigate to my local copy of the RBENV codebase and run `git checkout 1411fa5`:

<p style="text-align: center">
  <img src="/assets/images/navigating-to-correct-SHA.png" width="50%" alt="Running `git checkout` to check out the correct SHA." >
</p>

I run `ls bin/ruby-local-exec` to verify that the file exists in this version of the repo, then run `git co HEAD~` to check out the commit *just before* the current one and re-run `ls bin/ruby-local-exec` to verify that the file *no longer exists*, proving to myself that `1411fa5` is indeed the SHA which introduced this file:

<p style="text-align: center">
  <img src="/assets/images/verifying-no-file-exists.png" width="50%" alt="verifying I have the correct SHA." >
</p>

Now that I know I have the SHA which introduced this file, I can plug *that* back into Github search to look for any issues or discussions around this change:

<p style="text-align: center">
  <img src="/assets/images/gh-search-using-sha.png" width="50%" alt="Github search using SHA as search term." >
</p>

<p style="text-align: center">
  <img src="/assets/images/gh-search-using-sha-results.png" width="50%" alt="Results of Github search using SHA as search term." >
</p>

All we see is the 1 commit which introduced this change.  There are no issues associated with this commit.  Unfortunately, that means there is no discussion around why it was introduced or what problems it solves.

Fortunately, however, that origial commit includes comments at the top which largely answer our question:

<p style="text-align: center">
  <img src="/assets/images/original-ruby-local-exec-file.png" width="50%" alt="Original version of `ruby-local-exec` file." >
</p>

Let's look at this

We know what `set -e` does- it sets the file to exit immediately if an error occurs.  But what about `
 - It

### Aside- please don't do what I did here

While searching Github for answers to the above, I actually came across [a post of mine](https://github.com/rbenv/rbenv/issues/1173) on this same repository from 2019, where I asked this exact same question!  I only vaguely remember posting this, but I remember the person who answered me was much nicer and more detailed in his answer than he needed to be.  In retrospect, I'm a bit embarrassed that I posted this question instead of searching through the git history.  If everyone did what I did, open-source maintainers would be overwhelmed and would never get anything done.  I definitely don't recommend that you do what I did- instead, learn from my mistakes.  Github is not a 2nd StackOverflow.






## Summary - what we learned

 - What dotfiles and dot directories are
 - What version management is, and why it matters
 - What shims are
 - What a shebang is
 - What the `PATH` variable is, and how it's used
 - What the `set` command is, and how it's used
 - Using `set -e` to tell a `bash` script to exit immediately upon encountering an error
 - Using `set -x` to tell a `bash` script to run in verbose mode
 - How to look up documentation on our machine, using both the `man` and `help` commands
 - How to search the `man` and `help` pages if we're looking for a specific term
 - What a "shell" is
 - What a `.zshrc` file is
 - What POSIX is
 - What a "builtin" command is
 - How to find out which shell is your machine's default
 - How to form hypotheses on what our code does, and then run experiments to prove or disprove our hypotheses.
 - How to write boolean conditions in a shell script using the `[` or `test` command, as well as some useful flags for it (such as `-n` and `-f`).
 - How to conditionally execute arbitrary program logic based on the truthiness or falsiness of the above boolean conditions, using either `if` statements or `&&` one-liners.
 - What parameter expansion is, and some common use cases of it
 - double- vs. single-equals in a shell script
 - The difference between `[ ... ]` and `[[ ... ]]` in a shell script
 - What the internal field separator (aka `IFS`) is, and what it's useful for
 - How to iterate over arguments in a shell script, using a for-loop
 - Using the `$@` symbol to fetch the list of arguments provided to a script
 - How to write a case statement in `bash`
 - What `export` statements are, and why they're useful
 - The difference between shell variables and environment variables
 - The `exec` and `fork` commands, and when to use each one
 - What a "process" is
 - How to use Github and the repository's git history to figure out *why* the code is [the way that it is](https://www.youtube.com/watch?v=QXe1PkslirY).

And possibly more, as well.  I lost count lol.

## I still have more questions!

Such as:

 - We now know what this shim file is, but where did it come from?  How does RBENV generate a shim file for each of the Ruby programs I have installed?
 - I don't see a Ruby version number in the command `exec "/usr/local/bin/rbenv" exec "$program" "$@"`.  So the question remains- how does RBENV know which version number to use?

These and more questions will be answered in the upcoming soup-to-nuts walk-through of the RBENV codebase.  By the end of the walk-through, we will have learned:

 - how common `bash` programs like `sed` and `awk` work.
 - most importantly: what to do when you feel like giving up.

Sign up below to get notified when those posts are released!
