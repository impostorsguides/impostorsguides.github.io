---
layout: default
title: Introduction - How RBENV Shims Work
permalink: /rbenv/ch-0
category: rbenv
id: 0
---

<h1>{{ page.title }}</h1>

{% include_relative 0-a-content.md %}

{% include_relative 0-b-content.md %}

{% include_relative 0-c-content.md %}

## Tests and conditions

```
[ -n "$RBENV_DEBUG" ] && set -x
```

What do those brackets mean?  [This answer](https://stackoverflow.com/a/2188369/2143275) from StackOverflow says:

<p style="text-align: center">
  <img src="/assets/images/what-are-brackets.png" width="85%" alt="What are brackets in bash?" style="border: 1px solid black; padding: 0.5em">
</p>

OK, so `[` and `test` are synonyms as far as `bash` is concerned.  I run `man test` and see the following:

<p style="text-align: center">
  <img src="/assets/images/man-test.png" width="75%" alt="`man` entry for the `test` command" >
</p>

Here we have a formal definition of `[` (aka `test`).  It's a "condition evaluation utility", which I interpret to mean that it's similar to an if-clause in Ruby.  Let's test whether that's true with an experiment:

### Experiment- `[` vs `test`

I create a file named `./foo`:

```
 if [ 5 == 5 ]; then
   echo "True"
 else
   echo "False"
 fi
```

I run `chmod +x foo` so I can execute the script, then `./foo`:
```
$ ./foo

True
```

I then change the condition to `5 == 6` to make sure the `else` clause also works:

```
#!/usr/bin/env bash

 if [ 5 == 6 ]; then
   echo "True"
 else
   echo "False"
 fi
```

When I run it, I see:

```
$ ./foo

False
```

I then update the script to use the `test` command instead of the square brackets, and repeat the experiment:

```
 if test 5 == 5; then
   echo "True"
 else
   echo "False"
 fi
```

Same results:

```
$ ./foo

True
```

Lastly, testing the `else` clause...

```
#!/usr/bin/env bash

 if test 5 == 6; then
   echo "True"
 else
   echo "False"
 fi
```

...results in:

```
$ ./foo

False
```

At least in this case, `test` and `[ ... ]` appear to produce the same results.

Now what about that -n flag?

## Passing `-n` to `[`

If we’re looking for docs on a flag that we’re supposed to pass to a certain command, we can usually find those docs inside the docs for the command itself. In this case, I search for `-n` in the `man` page for `test`:

<p style="text-align: center">
  <img src="/assets/images/man-test-n.png" width="70%" alt="Documentation for the `test` command's `-n` flag">
</p>

It looks like `[ -n "$RBENV_DEBUG" ]` returns a zero exit code (or in the parlance of a true/false check, it returns `true`) if the length of the string that it receives is greater than zero (i.e. if the string is *not* empty).  In this case, the string it receives is the value of the `RBENV_DEBUG` environment variable.

Let's see if `-n` behaves the way we expect.

### Experiment- the `-n` flag

First I run the following directly in my terminal tab:

```
$ export FOO='foo'

$ [ -n "$FOO" ] && echo "Hi"

"Hi"

$ [ -n "$BAR" ] && echo "Hi"

$ [ -n "" ] && echo "Hi"

```

So using the `-n` flag to test the length of `FOO` resulted in printing `Hi` to the screen because `FOO` has a greater-than-zero string length.  But `BAR` and `""` both do not, so nothing was printed in those two cases.

This all works as expected.  Then, out of curiosity, I removed the double-quotes from `$BAR`:

```
$ [ -n $BAR ] && echo "Hi"
Hi
```

This was unexpected.  Since `$BAR` hadn't been set, I expected nothing to be printed to the screen.  I've read before that leaving the double-quotes off can cause unexpected behavior, depending on what the variable value is set to.  But if it's not set to anything, I would expect its length to be zero, and therefore the statement to return false.

Lastly, I removed `$BAR` entirely:

```
$ [ -n ] && echo "Hi"
Hi
```

Since I don't pass any value at all to the flag, I would expect the length of the non-existent "string" to be zero.

Why are the last two cases not returning the results I expect?

In this case, [this StackOverflow post](https://archive.ph/x5AYq) comes through with an answer:

> `[ -n ]` does not use the `-n` test.
>
> The `-n` in `[ -n ]` is not a test at all. When there is only one argument between `[` and `]`, that argument is a string that is tested to see if it is empty. Even when that string has a leading `-`, it is still interpreted as an operand, not a test. Since the string `-n` is not empty (it contains two characters, `-` and `n`, not zero characters) `[ -n ]` evaluates to true.

...and [here](https://unix.stackexchange.com/a/141025/142469):

> You need to quote your variables. Without quotes you are writing `test -n` instead of `test -n <expression>`. The `test` command has no idea that you provided a variable that expanded to nothing.

OK great.  So when I don't use double-quotes, the script thinks I'm just running `[ -n ]`, which the interpreter interprets as an operand of length 2, which is why it returns true.  This is true whether I'm running `[ -n ]` or `[ -n $BAR ]`.

-----------

Another question about the bracket syntax: what would happen if I used single-quotes instead of double-quotes?  Does that matter?  Time for another simple experiment.

### Experiment- single- vs. double-quotes

Since I've already defined my FOO variable in my terminal tab, I type the following in the same tab:

```
$ echo "$FOO"
```

Which results in:

```
foo
```

Next I use single-quotes:

```
$ echo '$FOO'
```

When I run it, I get the following:

```
$FOO
```

OK, so when using single-quotes instead of double-quotes, the shell doesn't expand the variable into its underlying value.  It just treats the variable name as a string literal, and in this case we echo that string to the terminal.

---------------

So if the `[ -n "$RBENV_DEBUG" ]` condition returns true, the `&&` syntax ensures that we then execute the 2nd half of this line of code: `set -x`.  If that condition returns false, we exit early and don't evaluate `set -x`.

We know about `set` already, but what does the `-x` flag do?

To find the answer, remember that we have to use `man zshoptions` to look up `set` flags:

<p style="text-align: center">
  <img src="/assets/images/man-zshoptions.png" width="75%" alt="`man` entry for the `zshoptions` command">
</p>

Using the `/` search command from within `man zshoptions`, we type `-x` and keep hitting the `n` key until we see the following:

<p style="text-align: center">
  <img src="/assets/images/man-zshoptions-2.png" width="75%" alt="`man` entry for the `zshoptions` command">
</p>

There were a few other "hits" while searching for `-x` in `man zshoptions`, but they were either for the wrong case (i.e. the uppercase `-X` instead of the lowercase `-x`, which is a different flag), or else were in the body of the description for another command (ex.- the description for `GLOBAL_EXPORT <Z>` contains a reference to `-x`, but does not tell us what `-x` does).

The `man` entry tells us that the `-x` flag causes `bash` to "(p)rint commands and their arguments as they are executed".  That kind of sounds to me like what "debug mode" or "verbose mode" does in many command line programs.  Which would make sense, given the condition for the `test` command included a variable named `RBENV_DEBUG`.

Let's see if that's what happens.

-------------

### Experiment- the `set -x` command

I write a new script, run `chmod +x` on it, and add the following code:

<p style="text-align: center">
  <img src="/assets/images/exp-set-x.png" width="30%" alt="Experiment script- `set -x`">
</p>

Side note- I found out from [this link](https://stackoverflow.com/questions/6348902/how-can-i-add-numbers-in-a-bash-script) that you add two integers in `bash` with the `$((...))` syntax.

As you can see, this script includes `set -x` at the top.  When I run this script, I see the following:

<p style="text-align: center">
  <img src="/assets/images/set-x-results.png" width="50%" alt="Results of a script with `set -x` included">
</p>

The lines with `+` in front of them appear to be the lines which are printed out *as a result of `set -x`*, while the lines without `+` are lines that would have printed out anyway (i.e. as a result of the `echo` commands I included in the script).

Now, when I comment out `set -x` and re-run the script, I see:

<p style="text-align: center">
  <img src="/assets/images/set-x-results-2.png" width="50%" alt="Results of the same script without `set -x`">
</p>

Now we don't see the `+` lines.

From this, I think we can conclude that `set -x` prints each line of code that is run, just as our docs described.

-----------

So to summarize, `[ -n "$RBENV_DEBUG" ] && set -x` tells us that we will print each command as it is executed, but **only if** we set the `$RBENV_DEBUG` environment variable to equal  any non-empty string value.

### Is it dangerous to rely on builtin commands?

Relatedly, while researching the `set` command, it dawned on me that if `man set` pulls up the "General Commands Manual", that must mean it's a builtin command (i.e. its implemented by a specific shell).  This is confirmed by a browse of [the GNU `bash` docs on `set`](https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html), titled "The Set Builtin".

But RBENV is a widely-popular Ruby version manager, meaning it must be running on machines that use `bash`, but also machines that use `zsh` and other shells too.

Our file has a `bash` shebang, meaning `set` will always be evaluated using `bash`.  But if we didn't have that shebang, would the `set` command (and therefore RBENV) behave differently in different shells?

More broadly, *is it dangerous for a script to rely on built-ins, since they could be implemented differently in different shells?*

I decide to [post my question on StackOverflow](https://stackoverflow.com/questions/73447693/rbenv-is-it-risky-to-rely-on-builtin-shell-commands-such-as-set-since-builti).  A side benefit of this is that, in the past, just the act of writing out my question on StackOverflow has helped unblock me and helped me answer my own question, even when I don't end up posting it.

The next day, I see someone commented on my question:

> As long as you stick to features from POSIX sh, you're usually pretty safe.

Googling for the phrase "POSIX docs", I find [the POSIX docs page](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_25) containing the `set` command, and verified that while it is considered a "special built-in", POSIX does have an opinion on its implementation:

> If no options or arguments are specified, `set` shall write the names and values of all shell variables in the collation sequence of the current locale.

The use of the word "shall" seems to indicate that a shell is required to implement its version of `set` in the manner prescribed by POSIX if it wants to be considered POSIX-compliant.  This, I think, is enough to satisfy my question.

Note that I subsequently found [this blog article](https://archive.ph/JGREI), which seems to confirm my assumption that POSIX is the standard by which we can feel safe in using `set` in the rbenv shim.

## Parameter Expansion

Moving on to the next line of code:

```
program="${0##*/}"
```

Judging by the variable name, it looks like we're trying to store the name of the program.  Let's see whether we're right with an experiment.

### Experiment- are we storing the string we think we're storing?

I edit the shim file (`~/.rbenv/shims/bundle`) to echo the value of `program` after the above line of code:

```
...
program="${0##*/}"
echo "program name: $program"
...
```

Then I run the following:

<p style="text-align: center">
  <img src="/assets/images/echo-program.png" width="50%" alt="echo the contents of the `program` variable">
</p>

Don't worry about `Could not locate Gemfile`- that's what happens when you try to run the `bundle` command in a directory without a file named `Gemfile`.  If I were to create an empty file named `Gemfile` and re-run the command, that error would go away and be replaced by a success message.

The important thing here is that the `bundle` command printed out `program name: bundle`.  Just to be safe, I do the same experiment with the shim for the `ruby` command (i.e. `~/.rbenv/shims/ruby`):

```
program="${0##*/}"
echo "program name: $program"
```

Then I run:

<p style="text-align: center">
  <img src="/assets/images/echo-program-2.png" width="50%" alt="echo the contents of the `program` variable">
</p>

Same thing- it printed the name of the first command I entered into the terminal, followed by the expected output of the `ruby -e "puts 5+5"` command.  By this point, I am confident that `${0##*/}` evaluates to "bundle" in my case.

Before I forget, I delete my `echo` commands from both the `bundle` and `ruby` shims.

But what is this weird syntax which evaluates to the name of the program?  After Googling that exact string ("${0##*/}"), I find [this StackOverflow link](https://archive.ph/1wCki), which says:

<p style="text-align: center">
  <img src="/assets/images/param-expansion-example-1.png" width="50%" alt="parameter expansion- first example" style="border: 1px solid black; padding: 0.5em">
</p>

We actually saw `$0` before, when we were testing out the name of our shell.  The author claims that `$0` will evaluate to the path of the file that we're executing.  This fits with that earlier test, because at that time, "the file that we're executing" was our shell program.

Let's test out what happens when that file is *not* a shell program.

### Experiment- messing around with parameter expansion

I create a directory named "foo".  Inside of that a subdirectory named "bar", and inside of that I create a file named "baz".  Inside of "baz" I type the following:

```
#!/usr/bin/env bash

echo "$0"
```

I then `chmod +x` it, so that it will execute:

```
$ chmod +x ./foo/bar/baz
```

And when I run it:

```
$ ./foo/bar/baz

./foo/bar/baz
```

The output was `./foo/bar/baz`, meaning we've verified that we can reproduce the `$0` behavior described in the StackOverflow post.

Based on the answer, I wondered whether wrapping `$0` in curly braces would change its output.  I tried this too:

```
#!/usr/bin/env bash

echo "${0}"
```

When I executed this updated version of `./foo/bar/baz`, it displayed the same output as before.  So `"$0"` and `"${0}"` seem to be functionally equivalent.

Now to test the 2nd part of the answer, about removing prefixes.  I'll first try the same syntax as in the StackOverflow answer (i.e. `##*/`):

```
#!/usr/bin/env bash

echo "${0##*/}"
```
When I run it:

```
$ ./foo/bar/baz

baz
```

So without the `##*/` syntax, we get `./foo/bar/baz` as our output.  **With** this new syntax, we get just `baz` as the output.  Therefore, adding `##*/` inside the curly braces had the effect of removing the leading `./foo/bar/` from `./foo/bar/baz`.

Out of curiosity, what happens when I remove one of the two "#" symbols?

```
#!/usr/bin/env bash

echo "${0#*/}"
```

Running it returns:

```
$ ./foo/bar/baz

foo/bar/baz
```

So instead of either `./foo/bar/baz` or `baz` as the output, now we get `foo/bar/baz`.  In other words, no leading `./` before `foo/`.

This is expected.  The StackOverflow answer mentions that including only one `#` will cause the parameter expansion to stop after matching the first case of its search pattern.  In this case, our search pattern is the `*/` character, meaning the first `/` character plus anything before it.  So one `#` will cause `./` to be removed, while two `##` will cause `./foo/foo/` to be removed.

Lastly, going back to the concept that the StackOverflow answer mentioned, i.e. "parameter expansion".  I Google around a bit and find [this link](https://web.archive.org/web/20220816200045/https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html), which looks like good documentation for me to bookmark and refer back to later, if I need to.

I feel like my understanding of the topic is good enough for now.  Next line of code.

## Conditional statements

```
if [ "$program" = "ruby" ]; then
...
fi
```

We already know what the bracket syntax does.  We also know we need double-quotes to expand our `program` variable safely.  And `if ... then` is one of the few bash commands which is likely to be readable to a layperson.  `fi` is just the way to close an `if` statement in `bash`.

So the purpose of this `if` check is to ensure the subsequent code only gets executed if the user typed `ruby` into the terminal as the program name.  Otherwise, nothing inside the `if` block gets executed.  Later, we'll examine that subsequent code and what it actually does.

The one thing that trips me up is the single equals sign.  In Ruby, we use single equals for variable assignment and double-equals for a comparison.  And in fact, we literally *just did that* here in `bash`-land, when we assigned to the `program` local variable using a single-equals sign.  But in bash, it looks like you can get away with single equals for a comparison operation, as long as the comparison is wrapped in square brackets?

Let's see whether this is true.

### Experiment- double- vs. single-equals comparison

I run the following experiment, in a new script file:

```
#!/usr/bin/env bash

program='ruby'
[ "$program" == "ruby" ] && echo "True"
```

When I `chmod` the file and run it, `True` prints out.  OK, using double-equals sign for a comparison operation does, in fact, work in bash.  I then remove one of the equals signs and run it again, and the same thing happens.  So it seems like, in bash, the double- and single-equals syntaxes are equivalent.

To confirm this further, I Google "bash double vs single equals" and I find [this StackOverflow post](https://stackoverflow.com/questions/12948456/is-there-any-difference-between-and-operators-in-bash-or-sh):

<p style="text-align: center">
  <img src="/assets/images/double-vs-single-equals.png" width="90%" alt="the difference between = and == in bash" style="border: 1px solid black; padding: 0.5em">
</p>

OK, so even though we're guaranteed to be using the `bash` shell by the time we execute this code (because of the shebang), we don't know *which version of `bash`* we're using.  It could be an older version, perhaps even one which doesn't support double-equals for a comparison operation.

Interestingly, I also try running the following directly in my terminal, without creating a whole new file (remember my terminal is zsh):

```
[ "$program" == "ruby" ] && echo "True"
zsh: = not found
```

So does that mean we can’t use double-equals in zsh?

To answer this, I Google around a bit and find [this link](https://archive.ph/2iSkK) for a StackOverflow question.  Apparently in `zsh`,...

```
a == is a logical operator only inside [[ ... ]] constructs.
```

I know that `==` is an example of a "logical operator", so the above implies that I need to use double-brackets in my command.

So what’s the difference between single- and double-`[`?

## Double- vs. single-`[`

[This StackOverflow page](https://web.archive.org/web/20220602085208/https://serverfault.com/questions/52034/what-is-the-difference-between-double-and-single-square-brackets-in-bash) provides some help:

<p style="text-align: center">
  <img src="/assets/images/brackets.png" width="70%" alt="bracket syntax in bash" style="border: 1px solid black; padding: 0.5em">
</p>

OK, so `[` is more POSIX-compliant than `[[`, therefore it’s more portable across a wider array of machines.  `[[` is more modern and comes with some helpful extras (like easier compatibility with `==`, as we saw earlier), so it can sometimes be easier to use.  But if you’re writing a script that will be used by many people and you can’t predict which shell they’ll run it on (or which version of a shell), you’re probably safer using `[`.

Lastly, I discovered further down in that StackOverflow link that I *can* use single-brackets with `==`, but I have to wrap the double-equals sign in quotes, like this:

```
[ "$program" '==' "ruby" ] && echo "True"
True

```

I thought it was interesting to highlight, but I doubt I'd ever bother going to that extra trouble, just to use double-equals.

## for-loops in bash

Moving onto the next line of code.

```
  for arg; do

  ...

  done
```
We saw a regular `bash` for-loop earlier, in our experiment with delimiters.  This loop is a bit weird, though, because we haven't yet seen an `arg` variable explicitly defined by the code.  Yet here it is, being referenced in our loop.

If we haven't seen this variable defined yet, does that mean it’s defined or built-in by the language?  As usual, Googling turns up [a StackOverflow post](https://archive.ph/p4Cjp):

<p style="text-align: center">
  <img src="/assets/images/arg-for-loop.png" width="70%" alt="What is `arg` in a bash `for` loop?" style="border: 1px solid black; padding: 0.5em">
</p>

Scrolling down in the answer a bit, we see:

<p style="text-align: center">
  <img src="/assets/images/arg-for-loop-2.png" width="70%" alt="Omitting `in` in a bash `for` loop?" style="border: 1px solid black; padding: 0.5em">
</p>

The above statement implies that `$@` expands to the list of arguments provided to the script.  Let’s see if that’s true with another experiment.

### Experiment- what does `$@` evaluate to?

I write a new script (again named simply "foo"):

```
#!/usr/bin/env bash

echo "$@"
```

Running the script with some random arguments, we get:

```
$ ./foo bar baz buzz

bar baz buzz
```

Changing the script a bit:

```
#!/usr/bin/env bash

for arg in "$@";
do
  echo "$arg"
done
```

Running this, we get:

```
$ ./foo bar baz buzz
bar
baz
buzz
```
And finally, testing whether we can eliminate `in "$@"`:

```
#!/usr/bin/env bash

for arg;
do
  echo "$arg"
done
```
Running this results in:

```
$ ./foo bar baz buzz
bar
baz
buzz
```

Awesome!  So we learned:

 - `$@` stands for the arguments that you pass to the script
 - If you write a `for` loop but leave off the `in ___` part, bash defaults to using `$@`

## Case statements

Moving on to the next line:

```
case "$arg" in
...
esac
```

I've seen case statements before (Ruby has them, as well), but I still feel like familiarizing myself with any bash-specific idiosyncracies.

I find [this link](https://web.archive.org/web/20220820011836/https://linuxize.com/post/bash-case-statement/), which explains bash’s case statement syntax.  I would have preferred a more official form of documentation, but:

 - [the link from The Linux Documentation Project](https://archive.ph/WCqYM) struck me as much-less beginner-friendly, and
 - neither `man case` nor `help case` turned up anything useful.

 At any rate, here are the highlights from the link I found:


1. Each `case` statement starts with the `case` keyword, followed by the case expression and the `in` keyword. The statement ends with the `esac` keyword.

1. You can use multiple patterns separated by the `|` operator. The `)` operator terminates a pattern list.

1. A pattern can have [special characters](https://web.archive.org/web/20220820011901/https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html).

1. A pattern and its associated commands are known as a clause.

1. Each clause must be terminated with `;;`.

1. The commands corresponding to the first pattern that matches the expression are executed.

1. It is a common practice to use the wildcard asterisk symbol (`*`) as a final pattern to define the default case. This pattern will always match.

1. If no pattern is matched, the return status is zero. Otherwise, the return status is the [exit status](https://web.archive.org/web/20220806222213/https://linuxize.com/post/bash-exit/) of the executed commands.

None of this is terribly surprising, since these rules all appear to match how case statements work in Ruby and other languages I've worked with.

### Experiment- building a simple `case` statement

In case this is your first time encountering case statements, let's build a simple one here.  I start by updating my `foo` script to look like the following:

```
#!/usr/bin/env bash

echo "$@"
```

I then run it as follows:

```
$ ./foo 1

1
```

Next, I wrap the existing code inside a `case` statement with only the default case implemented:

```
#!/usr/bin/env bash

case "$@" in
  *)
    echo "$@"
    ;;
esac
```

I still see the same output when I run it:

```
$ ./foo 1

1
```

Lastly, I add a few non-default conditions:

```
#!/usr/bin/env bash

case "$@" in
  "1" )
    echo "One"
    ;;
  "2" )
    echo "Two"
    ;;
  "3" )
    echo "Three"
    ;;
  *)
    echo "$@"
    ;;
esac
```

When I test the different edge cases, I get:

```
$ ./foo 1

One

$ ./foo 2

Two

$ ./foo 3

Three

$ ./foo 4

4
```

Interestingly, when I remove the quotes from around the numbers in the case statements, the script continues to function as normal.

### Pattern-matching in case statements

The earlier bullet points also explain the syntax of the subsequent line, which is a condition that the case statement will match against:

```
    -e* | -- ) break ;;
    ...
```

We see two patterns (`-e` and `--`), separated by the `|` character, then terminated by the `)` character, as mentioned in bullet point 2 above.  If the current arg in the iteration matches either pattern, we exit the `for` loop (i.e. we `break`).

Because of point #7 above, I suspect that any text starting with `-e` would fit the `-e*` pattern.  To prove it, I perform an experiment.

### Experiment- the `-e*` flag in a case statement

I write the following script:

```
#!/usr/bin/env bash

for arg; do
  case "$arg" in
    -e* ) echo "Pattern matched; exiting..."
    break ;;
    * )
      echo "arg is: $arg" ;;
  esac
done

echo "Outside the for loop"
```

This is a simplified version of the original case statement.  It iterates over the args, and if an arg matches `-e*`, we echo a test string ("Pattern matched; exiting...") and break out of the loop.  Otherwise, we just echo the arg itself and keep iterating.  When we’re done with all the args in the loop, we echo "Outside the for loop" to indicate that the script is finished.

I then run the following:

```
$ ./foo bar -ebaz buzz
arg is: bar
Pattern matched; exiting...
Outside the for loop
```

So we printed our first arg, and then "Pattern matched; exiting...", then we did *not* print the third arg (`buzz`).  This is because "-ebaz" starts with "-e", which matched the `break` condition of `-e*`.  Lastly, we printed "Outside the for loop" to prove that `break`ing doesn’t result in an exit of the entire script.  Based on this result, I think we can safely say that we were correct, and the `-e*` flag returns true if a given string starts with `-e`, regardless of what follows after.

To figure out what the `-e` flag actually does, I just ran `ruby –help` and searched for the `-e` entry.  This flag lets you execute Ruby code directly in your terminal, without having to pass a filename to the Ruby interpreter:

<p style="text-align: center">
  <img src="/assets/images/ruby-help-e.png" width="70%" alt="`ruby --help` output`">
</p>

For example:

```
$ ruby -e "puts 'Hello'"

Hello
```

So passing Ruby code directly to the `ruby` interpreter in your terminal (via the `-e` flag) is one of the two scenarios which will cause `rbenv` to assume that any **subsequent** args are meant to be positional args, not flags to the `ruby` command itself.

Regarding the 2nd pattern (`--`), I’ve seen it used in terminal commands before but I doubt I could explain its purpose.  StackOverflow [saves the day again](https://web.archive.org/web/20220623104640/https://unix.stackexchange.com/questions/11376/what-does-double-dash-mean):

<p style="text-align: center">
  <img src="/assets/images/double-dash.png" width="70%" alt="What is a double-dash?" style="border: 1px solid black; padding: 0.5em">
</p>

I think this means that everything before `--` is meant to be a flag, and everything after that is an argument to the script itself.

Hmmm OK, but you still need to be able to process the subsequent arguments in the script, right?  In our case, if the text matches the `--` pattern, does that mean the script breaks out of the list of args, meaning we won’t process anything after `--`?

Not quite.  We'll see shortly that the last line of the shim file makes use of `"$@"` again, specifically to pass those args to `$program`.  The value of `$@` is not modified at all by anything in the `for` loop, so all the args which get passed to the shim file are *also* passed in their original form to `$program`.  By `break`ing here, the only thing we're doing here is preventing those positional arguments from affecting the value of `RBENV_DIR`, which (as we'll see shortly) is the real purpose of the `for`-loop.

### More pattern-matching with case statements

Next line of code:

```
    */* )
      ...
      ;;

```

Judging by the `)` terminator character and the `;;` a few lines down, we can see that this is another pattern that the case statement will match against.  The only thing that throws me off is the difference between the above pattern (`*/* )`) and the one in my experiment script (`* )`), which I borrowed from the link on case statements.

The pattern searches for a forward-slash, with zero or more arbitrary characters before and/or after it.  To me, that looks like it's trying to match against a file path.  Let’s check that with an experiment.

### Experiment: how to check for a filepath in a case statement

I make a `bash` script which looks like so

```
#!/usr/bin/env bash

for arg; do
  case "$arg" in
    */* )
      echo "match: $arg";
    ;;
    * )
      echo "not a match: $arg";
    ;;
  esac
done
```

I then run the following in my terminal:

```
$ ./foo 1 2 3 a/b /b a/ / ''
not a match: 1
not a match: 2
not a match: 3
match: a/b
match: /b
match: a/
match: /
not a match:
```

So yes, it appears to be looking for strings which match the `/` symbol with zero or more characters of text on either side.

But just because it *looks* like a valid filepath, doesn't mean it *is* one.  So how do we know it’s a file?

## Detecting whether a string is a filepath

The next line of code tells us:

```
if [ -f "$arg" ]; then
...
fi
```

Running `man test` and searching for the `-f` string reveals the following:

<p style="text-align: center">
  <img src="/assets/images/man-test-f.png" width="70%" alt="What is the `-f` flag when passed inside brackets?">
</p>

> True if file exists and is a regular file.

So our case statement matches if the arg *could be* a filepath, and we further check this by using `[ -f "$arg" ]` to verify that it *actually is* a filepath.

FWIW, I'm guessing they say "regular file" here in order to distinguish from other types of files which are mentioned in other flag descriptions, such as "block special file" for the `-b` flag, and "character special file" for the `-c` flag.  I didn't spend too much time researching these special file types, because it doesn't look especially relevant to our goal here.  If you're curious about that, I found [this StackOverflow post](https://archive.ph/GVuaN) which appears to contain the answer.

To test whether the `-f` flag behaves the way I think it does, I update my `foo` script to look like the following:

```
#!/usr/bin/env bash

for arg; do
  case "$arg" in
    */* )
      echo "match: $arg";
      if [ -f "$arg" ]; then
        echo "is definitely a filepath";
      else
        echo "turns out, is not a filepath";
      fi
    ;;
    * )
      echo "not a match: $arg";
    ;;
  esac
done
```

Then I run:

```
$ echo "bar" > bar
```

I run this command so that I have a file in my directory called `./bar`.

Lastly, I run the following:

```
$ ./foo 1 2 3 a/b /b a/ / '' ./bar foo

not a match: 1
not a match: 2
not a match: 3
match: a/b
turns out, is not a filepath
match: /b
turns out, is not a filepath
match: a/
turns out, is not a filepath
match: /
turns out, is not a filepath
not a match:
match: ./bar
is definitely a filepath
not a match: foo
```

As expected, the arguments which are known to *not* match a file in my current directory (i.e. `a/b`, `/b`, `a/`, and `/`) result in the output `turns out, is not a filepath`.  My `./bar` argument, which is known to match a file, results in the output `is definitely a filepath`.

But wait, the last argument (`foo`) *also* matches a filepath, i.e. the `./foo` script we're running!  It doesn't match because it doesn't have a `/` in its argument, but it *still is* a file.  Does that mean the RBENV shim is accidentally *skipping* some filepaths which it should be capturing?

Let's try an experiment which should tell us whether this is in fact happening with the shim for the `ruby` command.

### Experiment- are we skipping potentially valid filepaths?

I update the shim for my `ruby` command to look like the following.  Newly-added lines are indicated with comments in blue at the right of the screenshot:

<p style="text-align: center">
  <img src="/assets/images/new-ruby-shim.png" width="70%" alt="shim for `ruby` command with echo statements">
</p>

I then make a new file called `bar.rb`, which just contains the following:

```
puts 5+5
```

When I run `ruby bar.rb`, I see the following:

```
$ ruby bar.rb

arg: bar.rb
-----
10
```

However, when I run `ruby ./bar.rb`, I see the following:

```
$ ruby ./bar.rb

arg: ./bar.rb
arg matches */*: ./bar.rb
about to set RBENV_DIR for arg ./bar.rb
10
```

Judging by the fact that we see `about to set RBENV_DIR...` in the 2nd test case but not the first, we can say that calling `ruby ./bar.rb` definitely causes additional code to be executed in our shim, above and beyond what gets executed when we only call `ruby bar.rb`.

Does this matter?

The answer to that is tied to what this case branch's purpose is.  We'll see what that is in the next section.

Before I move on, I make sure to delete the modifications I made to my `ruby` shim file.

Next 2 lines of code are:

```
export RBENV_DIR="${arg%/*}"
break
```

Here we see that the purpose of our case statement is to set the `RBENV_DIR` environment variable.

## What does the `RBENV_DIR` env var do?

To answer this question, I search for it in the `rbenv` codebase on my local machine (which I've downloaded from [the Github repo](https://github.com/rbenv/rbenv/tree/c4395e58201966d9f90c12bd6b7342e389e7a4cb)).

Note that I search using the `ag` command, which you can learn how to install [here](https://github.com/ggreer/the_silver_searcher).  Your computer will likely ship with the `grep` command, but `ag` is *much* faster.

When I run this search, I see multiple references to it in various code files:

<p style="text-align: center">
  <img src="/assets/images/ag-rbenv-dir.png" width="70%" alt="Searching the rbenv codebase for RBENV_DIR">
</p>

The reference that catches my eye is in the README.md file.  This file will likely tell me in plain English what I want to know.

Sure enough, I find that it contains the following table:

<p style="text-align: center">
  <img src="/assets/images/rbenv-env-vars.png" width="70%" alt="Environment variables in RBENV" style="border: 1px solid black; padding: 0.5em">
</p>

So the intention is for `RBENV_DIR` to control where `rbenv` looks for your `.ruby-version` file.  I happen to know from being a long-time RBENV user that the `.ruby-version` file is one way that RBENV uses to detect which Ruby version you want to use.  It’s quite common, when running a Ruby file that depends on a specific Ruby version, to include a `.ruby-version` file in the same directory as the executed file.  This file contains the hard-coded version number that you want to use when running your Ruby script, and is one method you can use to tell RBENV to pin your project to a specific Ruby version.

But what is the `export` keyword at the start of `export RBENV_DIR="${arg%/*}"`?

## `export` statements

The assignment statement `export FOO=’bar’` creates a variable named `FOO` and sets its value to `bar`, **but** it does something else as well.  We’ve already seen variables declared earlier, i.e. `program="${0##*/}"`.  What does the use of `export` buy us?

[It turns out](https://web.archive.org/web/20220713174024/https://www.baeldung.com/linux/bash-variables-export) there are two kinds of variables in a bash script: a shell variable and an environment variable.  When we created the `program` variable, that was an example of creating a **shell** variable.  Shell variables are only accessible from within the shell they’re created in.  Environment variables, on the other hand, are accessible from within child shells created by the parent shell.

The blog post link above gives two examples, one demonstrating access of an environment variable from a child shell, and the other of accessing a shell variable from a child shell.  We can do an experiment in our terminal to see for ourselves.

### Experiment- environment vs shell variables

We can type the following directly in our terminal:

```
$ export MYVAR1="Here is my environment variable"

$ MYVAR2="Here is my shell variable"

$ echo $MYVAR1

Here is my environment variable

$ echo $MYVAR2

Here is my shell variable

$ bash    # Open a new child shell

bash $ echo $MYVAR1

Here is my environment variable

bash $ echo $MYVAR2

```

We can see here that `MYVAR1` is visible from within our new child shell, but `MYVAR2` is not.  That's because the declaration of `MYVAR1` was prefaced with `export`, while the declaration of `MYVAR2` was not.

So our current line of code creates an environment variable called `RBENV_DIR`, which will be available in child shells.  This implies that we'll be creating a child shell soon.  What will that child shell do?

The short answer is that the child shell is used by RBENV to detect which Ruby version is the right one, and then run the original command corresponding to the shim that's being executed (i.e. `bundle` or whatever).

A deeper answer would require an explanation of how the RBENV codebase works as a whole, which is beyond the scope of this post.  But if you want to know more, I've already written a 500-page deep-dive into the codebase, written in the same format as this guide (with experiments, beginner-friendly explanations, etc).  Sign up below to get notified when I post it.

{% include convert_kit_2.html %}

In the meantime, what do the contents of the `RBENV_DIR` variable look like?  To answer that, we have to know what the following resolves to:

```
"${arg%/*}"
```

Let’s try an experiment.

### Experiment- more fun with parameter expansion

I type the following directly in my terminal:

```
$ arg="/foo/bar/baz"
$ bar="${arg%/*}"
$ echo $bar

/foo/bar
```

So `"${arg%/*}"` takes the argument, and trims off the last `/` character and everything after it.  This aligns with something I found earlier, in [the GNU docs](https://web.archive.org/web/20220816200045/https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html):

<p style="text-align: center">
  <img src="/assets/images/gnu-docs-param-expansion.png" width="70%" alt="GNU docs for parameter expansion" style="border: 1px solid black; padding: 0.5em">
</p>

As a reminder, the line of code that we're examining now is:

```
export RBENV_DIR="${arg%/*}"
```

With the above reminder, we now know enough to piece together what this line of code is doing:

 - It creates a new environment variable named `RBENV_DIR` which will be available in any child shells,
 - takes the directory of the file that was passed to the `ruby` command, and
 - sets the new env var equal to the *directory containing that Ruby file*.

------------

Here's a reminder of the entire `if` block we just looked at:

```
if [ "$program" = "ruby" ]; then
  for arg; do
    case "$arg" in
    -e* | -- ) break ;;
    */* )
      if [ -f "$arg" ]; then
        export RBENV_DIR="${arg%/*}"
        break
      fi
      ;;
    esac
  done
fi
```

Summing up what all this does:

 - If the command you’re running is the `ruby` command:
 - RBENV will iterate over each of the arguments you passed to `ruby`
 - If the arg is `--` or if it starts with `-e`, it will immediately stop checking the remaining args, and proceed to running the code outside the case statement (what that code does is TBD).
 - if the argument contains a `/` character, RBENV will check to see if that argument corresponds to a valid filepath.  If it does, it will grab the file’s parent directory and use that to (later on) check which Ruby version to use.

------------

The next line of code is pretty straight-forward:

```
export RBENV_ROOT="/Users/myusername/.rbenv"
```

## Setting `RBENV_ROOT`

This line of code just sets a 2nd environment variable named `RBENV_ROOT` to (in my case) the `.rbenv` hidden directory inside my home directory.  Referring back to the `README.md` file we just read, we see that this env var "Defines the directory under which Ruby versions and shims reside."  Given this is an env var and not a shell var, we can assume that this variable will be used by a child process.

------------

At last, we come to the final line of code in the shim:

```
exec "/usr/local/bin/rbenv" exec "$program" "$@"
```

## Executing the original gem

What does the `exec` command at the start of the line do?  I first try `man exec` but I get the "General Commands Manual", indicating that this is a builtin command.  I then try `help exec` and see:

```
$ help exec
exec [ -cl ] [ -a argv0 ] [ command [ arg ... ] ]
       Replace the current shell with command rather than forking.   If
       command  is  a  shell  builtin  command or a shell function, the
       shell executes it, and exits when the command is complete.
```

OK, so we're *replacing the current shell* with the command that we're running, "rather than forking".  What does that mean?  I Google "what is exec in bash", and one of the first links I find is from [ComputerHope](https://archive.ph/axmcj):

<p style="text-align: center">
  <img src="/assets/images/what-is-exec.png" width="70%" alt="What is the `exec` bash command?" style="border: 1px solid black; padding: 0.5em">
</p>

To be honest, that explanation creates more questions for me than it answers, including:

 - What's a process?
 - What's the difference between forking a process and replacing the current process with the new one (i.e. what `exec` does)?
 - Why use `exec` over forking, or vice-versa?

## What is a process?

I Google "what is a process in unix" and find a few answers.  The first one is from [TechTarget.com](https://archive.ph/1gKHE):

<p style="text-align: center">
  <img src="/assets/images/what-is-a-process.png" width="70%" alt="What is a process in UNIX?" style="border: 1px solid black; padding: 0.5em">
</p>

So from this definition, we learned that:

 - "A process is an instance of a program running on your computer."
 - One process (the "parent process") can create a new process (the "child process").
 - The child process shares resources with the parent process.  I'm not yet sure what resources they mean.
 - If the parent process dies, the child process also dies.

Another useful link comes from [TheUnixSchool.com](https://archive.ph/0qS4Y):

<p style="text-align: center">
  <img src="/assets/images/what-is-a-process-2.png" width="70%" alt="What is a process in UNIX?" style="border: 1px solid black; padding: 0.5em">
</p>

From this link, we additionally learned that:

 - A process has properties associated with it, such as a PID, a PPID, etc.
 - `ps` is a command we can use to see which processes are currently running.

OK, I guess this helps somewhat.  But what's the difference between `exec`ing and `fork`ing?

[This StackOverflow answer](https://stackoverflow.com/a/1653415/2143275) is a bit long, but it addresses this question:

<p style="text-align: center">
  <img src="/assets/images/fork-vs-exec.png" width="70%" alt="What's the difference between `fork` and `exec`?" style="border: 1px solid black; padding: 0.5em">
</p>

It appears that, if you know the parent process will be done after running the child process, then `exec` is the way to go because you can re-use the parent's process ID instead of creating a new one.  On the other hand, if the parent still has work to do after the child finishes executing, then `fork` is the way to go.

One use case they give for `fork`ing (rather than `exec`ing) is a web server that needs one process to spin off and handle a request that the server receives, while the parent thread continues to listen for new requests in a separate process.

## Experiment- messing around with `exec`

Directly in my terminal, I run:

```
$ exec "/usr/bin/env" ruby -e "puts 5"
5

[Process completed]
```

Since "the shell exits when the command is complete", the final output I see in my terminal tab is `[Process completed]`, and I can no longer run any commands in this tab.  I have to close this tab and open a new one to resume entering commands in the terminal.

Next, I want to see if I can observe this forking behavior as it happens.  I think I'll need to print out the current PID in order to do this, so I Google "how to print the current pid in bash" and find [this link](https://archive.ph/r5smn), which tells me to use `"$$"`.

I open a new tab, create a script named `./foo` to read as follows:

```
#!/usr/bin/env bash

echo "PID of foo: $$"

./bar
```

I `chmod` the above script to be executable, and I then create a script named `./bar` (also `chmod`'ed) which reads as follows:

```
#!/usr/bin/env bash

echo "PID of bar: $$"
```

In `./foo`, I'm just calling `./bar` directly, with no `exec` beforehand.  I theorize this will default to a `fork`, and that the PID printed by `./foo` will be different from that printed by `./bar`.  I run `./foo` in my terminal and see the following:

```
$ ./foo

PID of foo: 57955
PID of bar: 57956
```

In this case, I was right!  Now, I update `./foo` to preface `./bar` with a call to `exec`:

```
#!/usr/bin/env bash

echo "PID of foo: $$"

exec ./bar
```

When I run it, I get:

```
$ ./foo

PID of foo: 58695
PID of bar: 58695
```

Now the PIDs are the same!  This tells me that the `foo` process did indeed get **replaced** by the `bar` process.

-------------

So that’s what the shell builtin `exec` command does.  But the line of code we're looking at is:

```
exec "/usr/local/bin/rbenv" exec ...
```

This means we're running the builtin `exec` command, and *passing it* the `rbenv exec` command.  What does `rbenv exec` do?

For now, and to avoid having to dive into other files in the RBENV codebase, I just check whether `rbenv exec` accepts a `--help` command:

```
$ rbenv exec --help
Usage: rbenv exec <command> [arg1 arg2...]

Runs an executable by first preparing PATH so that the selected Ruby
version's `bin' directory is at the front.

For example, if the currently selected Ruby version is 1.9.3-p327:
  rbenv exec bundle install

is equivalent to:
  PATH="$RBENV_ROOT/versions/1.9.3-p327/bin:$PATH" bundle install
```

In other words, `rbenv exec` ensures that, when UNIX is checking `PATH` for a directory containing the command we entered, the first directory it finds is the one containing the version of Ruby you have set as your current version.  So the chain of events here is:

 - We call our program (i.e. `bundle` from the command line).
 - That call gets intercepted by the shim file.
 - The shim file calls `rbenv exec` to ensure that the version of Ruby we want to use is the first version that UNIX finds in our `PATH`.

**This is the heart of how RBENV ensures a clean separation of Ruby versions**- it stores them in separate folders, uses shims to intercept calls to Ruby programs, looks for your program in in the folder for your currently-selected Ruby version, and then executes *that* installation of your program.

But wait- why do we need the `ruby`-specific if block in *every* shim, regardless of whether it's a `ruby` shim or not?

## Investigating the origins of the `if` block in the shim file

If you give `ruby` a filename to run in the form of `path/to/filename.rb`, RBENV will look for the `.ruby-version` file in the file's directory *even if that directory is not the one you're in now*.  And that directory may have its own `.ruby-version` file, possibly containing a different Ruby version from the one you're currently using.

My theory is that the purpose of this logic is to handle the case where you're running a Ruby file from a different directory, one with a (potentially) different Ruby version.  To see whether this is true, let's use git and Github to find the commit which introduced this change.  From there, we can see whether there was any discussion around why it was introduced.

### Experiment- using git + Github to find where a change was introduced

In order to find the PR that introduced the if-block, I need the SHA for the commit from that PR.  But the shim files are auto-generated by RBENV whenever you install a new gem, meaning they're not part of a git repo (and hence don't have their own SHA).

However, since the shims are all the same, I bet there's a great chance that the shim code lives in a single file somewhere in the RBENV codebase, and is just copy-pasted into a new file whenever a new gem is installed.

I need to search the RBENV codebase for that code, so I pick a line from the if-block.  The line that I pick is one which I think will not be too common in the codebase, and therefore, it will have a high signal-to-noise ratio in my search results.  Then I use [the `ag` tool](https://github.com/ggreer/the_silver_searcher) to find its location:

<p style="text-align: center">
  <img src="/assets/images/ag-program-equals.png" width="70%" alt="searching or the shim code">
</p>

The only result I get is from a file named `libexec/rbenv-rehash`, on line 64.  Let's have a closer look at that line of code:

<p style="text-align: center">
  <img src="/assets/images/create-prototype-shim.png" width="50%" alt="the 'create-prototype-shim' method in rbenv-rehash">
</p>

Looks like it lives inside a function called `create_prototype_shim`.  Seems like we're on the right track!

Now that we know where in the RBENV codebase the if-block comes from, let's look at the git history for that file.  I copy the filepath for `rbenv-rehash` and run `git blame` on it (docs on this command [here](https://archive.ph/iSiLS)):

<p style="text-align: center">
  <img src="/assets/images/git-blame-rbenv-rehash.png" width="70%" alt="output of the `git blame` command for the `libexec/rbenv-rehash` file">
</p>

This is a lot of info, but what we care about is the left-most column.  It contains the first 8 characters of the commit's unique identifier (also called a SHA) which introduced each line of code.  In our case, we want line 64 (the line numbers are located in the 2nd-to-right column, just to the left of the actual lines of code).

Lucky for us, the SHA (`283e67b5`) is the same for the entire if-block, so we can be fairly confident that this is indeed the SHA which introduced the entire if-block.  If there were many different SHAs, each with different commit dates, that would indicate this code had been edited and re-edited many times, and any one of those SHAs could have been the original one.  In that case, it would be more of a slog to see which commit contained the info we're looking for.

I open my web browser and go to Github, where I paste the SHA value I copied from `git blame` into the search bar on the top-left and select "In this repository":

<p style="text-align: center">
  <img src="/assets/images/searching-github-for-sha.png" width="70%" alt="output of the `git blame` command for the `libexec/rbenv-rehash` file" style="border: 1px solid black; padding: 0.5em">
</p>

Although Github says "we couldn't find any code...", we're not looking for answers from the *codebase*, but rather from the *git history*.  And on the left-hand side, we can see that Github did find one issue and one commit containing this SHA.  I right click on each section to open them in new tabs.

First the commit results:

<p style="text-align: center">
  <img src="/assets/images/git-commit-history-for-sha.png" width="70%" alt="Github's results for the commit history containing our SHA" style="border: 1px solid black; padding: 0.5em">
</p>

Reconstructing the commit message (which was cut off due to length), we can see at the top that the commit message for this commit was:

```
When the ruby shim is invoked with a script, set RBENV_DIR to the script's dirname
```

This definitely sounds like we're on the right track.  Let's also check [the issue link](https://github.com/rbenv/rbenv/pull/299):

<p style="text-align: center">
  <img src="/assets/images/rbenv-issue-page.png" width="50%" alt="The newer Github issue related to the PR which introduced this if-block." style="border: 1px solid black; padding: 0.5em">
</p>


The description says `This branch adjusts the behavior of the ruby shim, when invoked with the path to a Ruby script as an argument, to set RBENV_DIR to the directory of the given script.  It should, in effect, remove the need for the ruby-local-exec shebang line.`  That sounds pretty close to what we hypothesized.

Based on this, I think we can safely say that the if-block was added in order to take the Ruby script's filesystem location into account when setting the `RBENV_DIR` environment variable, *regardless of whether it's located in the current directory tree or a different one*.

## The `ruby-local-exec` shebang

But there's something here I still don't understand, specifically that 2nd sentence `It should, in effect, remove the need for the ruby-local-exec shebang line.`  It sounds like there was a previous attempt to solve the problem of setting `RBENV_DIR` which involved a special type of shebang, called `ruby-local-exec`.  That makes me wonder:

 - How did `ruby-local-exec` originally work?
 - Why did the core team feel the need to replace it?  What was wrong with it?
 - Why was our adding of the `if`-block an improvement on that old strategy?

### Looking for `ruby-local-exec`

I suspect that `ruby-local-exec` is a file.  After all, the interpreters that shebangs use (such as the `bash` in `#!/usr/bin/env bash` or the `ruby` in `#!/usr/bin/env ruby`) are just executable files, so `ruby-local-exec` might be a file too.  If it is a file, there must have been a git commit somewhere which introduced the file.  Maybe we can use the same strategy here that we used with the if-block.

Since our original Github issue said that the need for the `ruby-local-exec` shebang had been removed, I suspect this file no longer exists in the codebase.  I run `find . -name ruby-local-exec` and no results appear, so that seems to check out.  This means I have to search Github for an older version of the repository which contains the file.

I type "ruby-local-exec" in Github's search field while inside the Github repository (i.e. while my browser is pointed to `https://github.com/rbenv/rbenv`).  When I do this, the "In this repository" option appears in a dropdown, and I click that.

<p style="text-align: center">
  <img src="/assets/images/ruby-local-exec-search.png" width="70%" alt="Searching Github for the string 'ruby-local-exec'." style="border: 1px solid black; padding: 0.5em">
</p>

I'm taken to a search results page, which (among other things) indicates that Github found 6 commits with this string present.  I click on "Commits" to see which commits those were:

<p style="text-align: center">
  <img src="/assets/images/search-results-for-ruby-local-exec.png" width="70%" alt="Github Search results for the string 'ruby-local-exec'." style="border: 1px solid black; padding: 0.5em">
</p>

From there, I see a list of git commits, along with their commit messages.  The commit labeled "Add experimental `ruby-local-exec`" [looks promising](https://github.com/rbenv/rbenv/commit/1411fa5a1624ca5eeb5582897373c58a715fe2d2), so I click on that:

<p style="text-align: center">
  <img src="/assets/images/search-results-for-ruby-local-exec-2.png" width="70%" alt="Github Search results for the string 'ruby-local-exec'." style="border: 1px solid black; padding: 0.5em">
</p>

From there, I'm taken to a list of files, which (in the case of this PR) is just one file- the one I want (`bin/ruby-local-exec`):

<p style="text-align: center">
  <img src="/assets/images/ruby-local-exec-commit.png" width="70%" alt="The original commit for the 'ruby-local-exec' file." style="border: 1px solid black; padding: 0.5em">
</p>

Great, so we finally have confirmation that `ruby-local-exec` was indeed a file at some point.

### What does `ruby-local-exec` actually do?

Now that we have the file, we can read its code to answer question #1 above ("How did `ruby-local-exec` originally work?").

The code for `ruby-local-exec` was as follows:

```
set -e

cwd="$(pwd)"
dirname="${1%/*}"

cd "$dirname"
export RBENV_VERSION="$(rbenv version-name)"
cd "$cwd"

exec ruby "$@"
```

The first line was:

```
set -e
```

We've seen this command before, so we know what that does- it tells `bash` to exit immediately when it encounters an error.

```
cwd="$(pwd)"
```

We're storing something in a variable called "cwd", but what?

The `pwd` string looks like the `pwd` bash command I'm previously familiar with.  It stands for "print working directory", and it prints the full path for the directory you're currently in:

```
$ pwd

/Users/myusername/Workspace/OpenSource
```

And it *almost* looks like we're doing parameter expansion again, except this time the syntax uses parentheses instead of curly braces.  Is that what this is?

I Google "bash difference between brackets and parentheses", and the first link I get is [this StackOverflow post](https://archive.ph/3IjOm) with this answer:

<p style="text-align: center">
  <img src="/assets/images/parens-in-bash.png" width="70%" alt="What is the difference between curly braces and parentheses in bash?" style="border: 1px solid black; padding: 0.5em">
</p>

OK, so "Parentheses cause the commands to be run in a subshell."  What's a subshell?

I Google "what is a subshell bash" and get [this link](https://archive.ph/7mszR):

<p style="text-align: center">
  <img src="/assets/images/what-are-subshells.png" width="70%" alt="What are subshells in bash?" style="border: 1px solid black; padding: 0.5em">
</p>

So the code `cwd="$(pwd)"` creates a subshell, runs the `pwd` command inside that subshell, and stores the output of the command inside a new variable named `cwd`.  I subsequently learned that this is also known as ["command substitution"](https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html).

```
dirname="${1%/*}"
```

This is definitely parameter expansion again.  What effect does the `%/*` have?  Referring back to [an earlier section of this post](#experiment--more-fun-with-parameter-expansion), we're reminded that `%/*` trims off the last `/` character and everything after it.  Which makes sense if we're trying to capture a directory name in a variable named `dirname`.

To see which dirname we're storing, I run an experiment.

### Experiment- creating our own shebang

I copy-paste the original `ruby-local-exec` into a new file in my current directory (remembering to run `chmod +x` on that new file).  I add a few `echo` loglines, like so:

<p style="text-align: center">
  <img src="/assets/images/new-shebang.png" width="50%" alt="contents of my copy of the ruby-local-exec shebang" >
</p>

I then create a new file called `foo`, which looks like so:

<p style="text-align: center">
  <img src="/assets/images/using-the-new-shebang.png" width="50%" alt="using the new shebang" >
</p>

The `ruby-local-exec` shebang is meant to execute Ruby scripts, so my `foo` script uses Ruby syntax like the `puts` statement.

The last thing I have to do is update my `PATH` variable to begin with my current directory, so that UNIX will know where to find the `ruby-local-exec` file (and therefore, it will know how to run my `foo` script).  I can feel free to do this directly in my terminal without worrying that it'll cause any damage- changes to my `PATH` that I make directly at the command line won't be propagated to any other terminal tabs I open.

I run the following in my terminal:

```
$ PATH="$(pwd):$PATH"
$ which ruby-local-exec

/Users/myusername/Workspace/OpenSource/rbenv/ruby-local-exec
```

Running `which ruby-local-exec` shows me that UNIX can now find my `ruby-local-exec` command in `PATH`.  Now, when I run `./foo` in my terminal, I see:

```
$ ./foo

start of ruby-local-exec
dirname: .
just before exec in ruby-local-exec
Hello world
```

We see that `dirname` evaluates to `.`.  I suspect this is because I ran the command as `./foo` and the parameter expansion chopped off the trailing `/foo`.  When I re-run the command with the full directory, I see:

```
$ pwd
/Users/myusername/Workspace/OpenSource/rbenv

$ /Users/myusername/Workspace/OpenSource/rbenv/foo

start of ruby-local-exec
dirname: /Users/myusername/Workspace/OpenSource/rbenv
just before exec in ruby-local-exec
Hello world
```

This time, `dirname` evaluates to `/Users/myusername/Workspace/OpenSource/rbenv`.  This must mean that, inside the shebang file, the parameter expansion `${1}` evaluates to the filename.  We can quickly test this by adding a logline to output just that, without any modifications to `$1`.  Above the logline for `dirname` inside my new shebang, I add:

```
echo "1: ${1}"
```

When I re-run, I get:

```
$ /Users/myusername/Workspace/OpenSource/rbenv/foo

start of ruby-local-exec
1: /Users/myusername/Workspace/OpenSource/rbenv/foo
dirname: /Users/myusername/Workspace/OpenSource/rbenv
just before exec in ruby-local-exec
Hello world
```

Yep, `${1}` inside the shebang evaluated to the filename.

Next line of code:

```
cd "$dirname"
```

Here we're just using `cd` to navigate into the dirname we just stored.  We don't yet know why (that will come later), but this line is straight-forward.

Next line:

```
export RBENV_VERSION="$(rbenv version-name)"
```

Here we're again using command substitution, this time to store the output of `rbenv version-name` in an environment variable named `RBENV_VERSION`.  What's the output of `rbenv version-name`?  Running it in my terminal, I see:

```
$ rbenv version-name

2.7.5
```

OK, so we're just storing the current Ruby version inside `RBENV_VERSION`.  But is it the version of the folder we're in, or the version of the folder containing our Ruby script?

Before moving on, I remove all the loglines I've added to `ruby-local-exec` so far.

### Experiment- which directory's Ruby version does `RBENV_VERSION` contain?

I add a logline inside my new shebang file, just after the assignment to `RBENV_VERSION`, which will `echo` the contents of that env var:

```
echo "RBENV_VERSION: $RBENV_VERSION"
```

I then create a `.ruby-version` file in the same directory as my `foo` script, containing only the string "2.7.5":

```
$ echo "2.7.5" > .ruby-version
```

I then navigate up one directory create a new directory called `bar`, navigate into that, and create a 2nd `.ruby-version` file in this directory, which I set to "3.0.0":

```
~/Workspace/OpenSource/rbenv (master)  $ cd ..
~/Workspace/OpenSource ()  $ mkdir bar
~/Workspace/OpenSource ()  $ cd bar
~/Workspace/OpenSource/bar ()  $ echo "3.0.0" > .ruby-version
~/Workspace/OpenSource/bar ()  $
```

Lastly, I copy my `foo` script from the `rbenv` directory into my new `bar` directory:

```
$ cp ../rbenv/foo .
```

Then, from the `bar` directory, I execute the `foo` script *in the `rbenv` directory*:

```
$ ../rbenv/foo

RBENV_VERSION: 2.7.5
Hello world
```

Lastly, when I run the copy of `foo` *in the `bar` directory*, I see:

```
$ ./foo

RBENV_VERSION: 3.0.0
Hello world
```

So when I run the copy of `foo` in the `rbenv` directory, I see that `RBENV_VERSION` is `2.7.5`.  But when I run `foo` from the `bar` directory, I see `3.0.0`.  We can therefore conclude that RBENV will first look for a `.ruby-version` file in the directory of the script that is being executed, before checking in any other locations (such as the directory the user is currently in when they execute that script).

--------

Next line of code:

```
cd "$cwd"
```

So now we're just changing back to the directory we were originally in when we stored `pwd` inside the `cwd` variable.  Essentially we just ran `cwd="$(pwd)"` so that we would know where to navigate back to after we had stored the right Ruby version inside `RBENV_VERSION`.

Last line of code:

```
exec ruby "$@"
```

Here we're using the `exec` command that we learned about [earlier](#executing-the-original-gem), using it to call `ruby`, and passing along any arguments that the script may have received.  Remember that this will be the *shim* of Ruby, not the original Ruby interpreter itself.

OK, so that's the answer to our first question, about what `ruby-local-exec` does!  Now for question #2: why did the core team feel the need to replace it?

### Why did the core team replace `ruby-local-exec`?

For this, we'll have to search for discussions amongst the core team (in the form of comments and issues on Github pages) which relate to this file.  I don't remember [our original Github issue page](https://github.com/rbenv/rbenv/pull/299) containing any of those discussions, but I do remember that there was a link to a previous discussion:

<p style="text-align: center">
  <img src="/assets/images/see-previous-discussion.png" width="70%" alt="Link to an earlier discussion about ruby-local-exec." style="border: 1px solid black; padding: 0.5em">
</p>

Clicking this link, I'm taken to [the page for an earlier PR](https://github.com/rbenv/rbenv/pull/298), one that was apparently closed.  The IDs of the 2 PRs are sequential (the IDs are 298 for the cloed one and 299 for the merged one), and their intent is identical, so it's a safe bet that the earlier one was closed in favor of the later one.

### Side note- Why the switch from `.rbenv-version` to `.ruby-version`?

This PR's discussion references a file named `.rbenv-version`, which is of course different from the `.ruby-version` file we've previously discussed.  My guess is that, at some point, the RBENV core team switched from a naming convention of `.rbenv-version` to `.ruby-version`, in order to be slightly more inter-operable with other Ruby version managers.  A quick Github search in the RBENV repo for `".rbenv-version" ".ruby-version"` (so that I can find PRs which contain both terms) yields 8 results, of which [this PR](https://github.com/rbenv/rbenv/pull/302) is one.  This quote in particular stands out among the comments:

<p style="text-align: center">
  <img src="/assets/images/switch-rbenv-version-to-ruby-version.png" width="70%" alt="Comments discussing the support of the '.ruby-version' filename over '.rbenv-version'." style="border: 1px solid black; padding: 0.5em">
</p>

This largely confirms my suspicions about inter-operability.

FWIW, there's also a comment by Sam Stephenson (the original author and member of the core team) saying:

```
We will maintain backwards compatibility with existing .rbenv-version files for the foreseeable future.
```

However, when I search my local version of the codebase for `.rbenv-version`, nothing is returned, whereas `.ruby-version` has plenty of references.  So I'm guessing that the plan to support the `.rbenv-version` filename convention must have scrapped at some point.

### Looking for the commit which added `ruby-local-exec`

On the right-hand side of the screen, I see the following:

<p style="text-align: center">
  <img src="/assets/images/commit-SHA-for-ruby-local-exec.png" width="50%" alt="Original commit SHA for the 'ruby-local-exec' file." style="border: 1px solid black; padding: 0.5em">
</p>

Among other things, this tells us that the SHA for this commit starts with `1411fa5`.  In my terminal, I navigate to my local copy of the RBENV codebase and run `git checkout 1411fa5`:

<p style="text-align: center">
  <img src="/assets/images/navigating-to-correct-SHA.png" width="50%" alt="Running `git checkout` to check out the correct SHA." >
</p>

I run `ls bin/ruby-local-exec` to verify that the file exists in this version of the repo, then run `git co HEAD~` to check out the commit *just before* the current one and re-run `ls bin/ruby-local-exec` to verify that the file *no longer exists*:

<p style="text-align: center">
  <img src="/assets/images/verifying-no-file-exists.png" width="50%" alt="verifying I have the correct SHA." >
</p>

This proves that `1411fa5` is indeed the SHA which introduced the shebang file.

### Checking Github for context around this SHA

Now that I know I have the SHA which introduced this file, I can plug *that* back into Github search to look for any issues or discussions around this change:

<p style="text-align: center">
  <img src="/assets/images/gh-search-using-sha.png" width="50%" alt="Github search using SHA as search term." style="border: 1px solid black; padding: 0.5em">
</p>

<p style="text-align: center">
  <img src="/assets/images/gh-search-using-sha-results.png" width="50%" alt="Results of Github search using SHA as search term." style="border: 1px solid black; padding: 0.5em">
</p>

All we see is the 1 commit which introduced this change.  There are no issues associated with this commit.  Unfortunately, that means there is no discussion around why it was introduced or what problems it solves.

### A last resort

As a last resort, I try ChatGPT haha:

<!-- ChatGPT link- https://chat.openai.com/chat/1a2694aa-d446-46b0-a1dd-f40d24377efb -->

<p style="text-align: center">
  <img src="/assets/images/chat-gpt-why-change-shebang.png" width="70%" alt="Asking ChatGPT why RBENV changed their shebang from `ruby-local-exec` to `ruby`."  style="border: 1px solid black; padding: 0.5em">
</p>

ChatGPT says that the newer `ruby` shebang is simpler, more reliable, and more portable than the old `ruby-local-exec` shebang.  Though I don't have any non-AI-generated evidence to support this, it seems like a plausible explanation.

### A warning- getting burned by ChatGPT

I don't want to imply that ChatGPT is a good resource to use in all cases.  It definitely pays to verify any claims it makes.

For example, when I was trying to figure out why files aren't executable-by-default by their creator, I hit a dead end where I couldn't find an authoritative answer online.  So once again, I turned to ChatGPT.  This time the answer it gave me was misleading.  The question I asked was:

```
In a UNIX environment, why aren't new files executable by the creator of the file until you run the `chmod`
command?  Shouldn't the file's creator automatically have the ability to execute the file?
```

And the answer it gave was:

<p style="text-align: center">
  <img src="/assets/images/chat-gpt-why-arent-files-executable-by-default.png" width="70%" alt="Asking ChatGPT why files aren't executable by their creator until `chmod` is run.">
</p>

The answer is partially correct (the goal of the policy is in fact to prevent a malicious user from executing code which could harm your system).  But I wanted to verify the statement `When a new file is created, it inherits the default permissions of the directory it was created in...`.

So I did an experiment.  I made a directory and verified that its permissions were such that the user who created it could "execute" it:

```
$ mkdir foo

$ chmod +x foo

$ ls -l

...
drwxr-xr-x   3 myusername  staff   96 Mar  6 08:43 foo
...
```

Then I created a file inside that directory.  But that file was not, by default, executable by its creator:

```
$ touch foo/bar

$ ls -l foo

total 0
-rw-r--r--  1 myusername  staff  0 Mar  6 08:43 bar
```

This implies that the `foo/bar` file did not inherit its permissions from its parent directory, and that the ChatGPT statement was incorrect.

For added confirmation, I Googled `do unix files inherit the permissions of a directory`, and got [this link](https://archive.ph/uQX9j#selection-1631.0-1645.117) as the first result:

<p style="text-align: center">
  <img src="/assets/images/file-permissions-inheritance-in-unix-1.png" width="70%" alt="Confirming that ChatGPT was not, in fact, correct about UNIX file permissions inheritance.">
</p>

This is confirmed by [this StackOverflow post](https://archive.ph/SFV8x):

<p style="text-align: center">
  <img src="/assets/images/file-permissions-inheritance-in-unix-2.png" width="50%" alt="More confirmation that ChatGPT was not, in fact, correct about UNIX file permissions inheritance.">
</p>

So lesson learned- we can't trust ChatGPT implicitly.

## How was the if-block an improvement on the old solution?

Prior to this change, did RBENV use the Ruby version in the directory from which it was run, *regardless* of what the Ruby version was in the target directory?  To find out, roll back my RBENV and do an experiment.

I `cd` into my RBENV **installation directory** (i.e. `~/.rbenv`), and verify that it is a git repository by running `ls -la` and searching for the `.git` hidden directory.  Then I get the commit SHA from [this link](https://github.com/rbenv/rbenv/pull/299), which I see is SHA `e0b8938fef05dd6d08322e113015c51e79c70291`.  I then run `git checkout e0b8938fef05dd6d08322e113015c51e79c70291` to roll back my installed version to the commit which introduced this change.

Next, in my scratch directory (`~/Workspace/OpenSource`), **I open a new terminal tab**.  This way I'm still in my same directory, but opening the new tab caused my `~/.zshrc` (where I invoke `rbenv init`) to be re-run.  This ensures I'm now using the version of RBENV that I just checked out (i.e. the version corresponding to SHA `e0b8938fef05dd6d08322e113015c51e79c70291`).

I then create two directories in my scratch directory- one named `foo/` and one named `bar/`.  I create a `.rbenv-version` file inside each directory- one set to `3.0.0` in `foo/` and the other set to `2.7.5` in `bar/`.  I then create a file named `script`, which I `chmod +x` so it's executable.  The file looks like this:

```
#!/usr/bin/env ruby

ruby_version = `rbenv version`
puts "Ruby version: #{ruby_version}"
```

The `\`` backtick symbols surrounding `rbenv version` mean that we will run the `rbenv version` terminal command, and store the results in the variable named `ruby_version`.  This process is sometimes called [shelling out](https://stackoverflow.com/a/28655406/2143275) to a sub-process.

I then copy the above `script` file from `foo/` into `bar/`, so an identical file exists in each new directory.  When I run `./script` from within `foo/`, followed by `../bar/script` (also from within `foo/`), I see:

```
~/Workspace/OpenSource/foo ()  $ ./script

Ruby version: 3.0.0 (set by /Users/myusername/Workspace/OpenSource/foo/.rbenv-version)

~/Workspace/OpenSource/foo ()  $ ../bar/script

Ruby version: 2.7.5 (set by /Users/myusername/Workspace/OpenSource/bar/.rbenv-version)
```

Next, back in the `~/.rbenv/` directory, I check out the commit **before** the one which introduced this change:

```
$ git co e0b8938fef05dd6d08322e113015c51e79c70291~

Previous HEAD position was e0b8938 Merge pull request #299 from sstephenson/automatic-local-exec
HEAD is now at 811ca05 Run `hash -r` after `rbenv rehash` when shell integration is enabled
```

Then, back in my `foo/` directory, **I open a new terminal tab again**.  Lastly, when I re-run my two scripts, this time I see:

```
$ ./script

Ruby version: 2.7.5 (set by RBENV_VERSION environment variable)

~/Workspace/OpenSource/foo ()  $ ../bar/script

Ruby version: 2.7.5 (set by RBENV_VERSION environment variable)

~/Workspace/OpenSource/foo ()  $
```

This time, the version numbers are the same- `2.7.5`!  Also, the source of the versions has changed- previously, along with the version number, we saw `(set by /Users/myusername/Workspace/OpenSource/bar/.rbenv-version)` in the output.  This time, we see `(set by RBENV_VERSION environment variable)`.  So in both cases, the `.rbenv-version` file was **not** being used to set the version.

### Please don't do what I did here

While searching Github for answers to the above, I actually came across [a post of mine](https://github.com/rbenv/rbenv/issues/1173) on this same repository from 2019, where I asked this exact same question!

I only vaguely remember posting this, but I remember the person who answered me was much nicer and more detailed in his answer than he needed to be.  In retrospect, I'm a bit embarrassed that I posted this question instead of searching through the git history.  If everyone did what I did, open-source maintainers would be overwhelmed and would never get anything done.  I definitely don't recommend that you do what I did- instead, learn from my mistakes.  Github is not a 2nd StackOverflow.

It took multiple read-throughs of the issue at hand, spread out over many weeks, along with trial-and-error in the form of experimentation.  But **eventually** I was able to figure this out on my own, without relying on the above post.  If you've read this far and slogged through all my experiments with me, I'm confident you can do likewise.

## Summary - what we learned

 - What dotfiles and dot directories are
 - What version management is, and why it matters
 - What shims are
 - What a shebang is
 - What the `PATH` variable is, and how it's used
 - What the `set` command is, and how it's used
 - Using `set -e` to tell a `bash` script to exit immediately upon encountering an error
 - Using `set -x` to tell a `bash` script to run in verbose mode
 - How to look up documentation on our machine, using both the `man` and `help` commands
 - How to search the `man` and `help` pages if we're looking for a specific term
 - What a "shell" is
 - What a `.zshrc` file is
 - What POSIX is
 - What a "builtin" command is
 - How to find out which shell is your machine's default
 - How to form hypotheses on what our code does, and then run experiments to prove or disprove our hypotheses.
 - How to write boolean conditions in a shell script using the `[` or `test` command, as well as some useful flags for it (such as `-n` and `-f`).
 - How to conditionally execute arbitrary program logic based on the truthiness or falsiness of the above boolean conditions, using either `if` statements or `&&` one-liners.
 - What parameter expansion is, how to use it, and some common use cases
 - double- vs. single-equals in a shell script
 - The difference between `[ ... ]` and `[[ ... ]]` in a shell script
 - What the internal field separator (aka `IFS`) is, and what it's useful for
 - How to iterate over arguments in a shell script, using a for-loop
 - Using the `$@` symbol to fetch the list of arguments provided to a script
 - How to write a case statement in `bash`
 - What `export` statements are, and why they're useful
 - The difference between shell variables and environment variables
 - The `exec` and `fork` commands, and when to use each one
 - What a "process" is
 - How to use Github and the repository's git history to figure out *why* the code is [the way that it is](https://www.youtube.com/watch?v=QXe1PkslirY).
 - What command substitution is and how to use it

And possibly more, as well.  I lost count lol.

## I still have more questions!

Such as:

 - We now know what this shim file is, but where did it come from?  How does RBENV generate a shim file for each of the Ruby programs I have installed?
 - What happens inside the child process that gets created by the call to `exec` at the end of the shim file?
 - We still haven't seen the actual logic which picks the right version number, so it must be happening somewhere else.  Where does that live, and how does it work?

These and more questions will be answered in the upcoming soup-to-nuts walk-through of the RBENV codebase.  By the end of the walk-through, we will have learned:

 - how common `bash` programs like `sed` and `awk` work.
 - most importantly: what to do when you feel like giving up.

Sign up below to get notified when those posts are released!

{% include convert_kit_2.html %}
